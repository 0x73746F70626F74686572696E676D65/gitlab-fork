# frozen_string_literal: true
#
module Gitlab
  module Diff
    class HighlightCache
      EXPIRATION = 1.week

      delegate :diffable, to: :@diff_collection
      delegate :diff_options, to: :@diff_collection

      def initialize(diff_collection, backend: Rails.cache)
        @backend = backend
        @diff_collection = diff_collection
        @redis_key = diffable.cache_key if Feature.enabled?(:redis_diff_caching)
      end

      # - Reads from cache
      # - Assigns DiffFile#highlighted_diff_lines for cached files
      def decorate(diff_file)
        if content = read_file(diff_file)
          diff_file.highlighted_diff_lines = content.map do |line|
            Gitlab::Diff::Line.init_from_hash(line)
          end
        end
      end

      # It populates a Hash in order to submit a single write to the memory
      # cache. This avoids excessive IO generated by N+1's (1 writing for
      # each highlighted line or file).
      def write_if_empty
        return if cached_content.present?

        @diff_collection.diff_files.each do |diff_file|
          next unless cacheable?(diff_file)

          diff_file_id = diff_file.file_identifier

          cached_content[diff_file_id] = diff_file.highlighted_diff_lines.map(&:to_hash)
        end

        if Feature.enabled?(:redis_diff_caching)
          write_to_redis_hash(cached_content)
        else
          cache.write(key, cached_content, expires_in: 1.week)
        end
      end

      # Given a hash of:
      #   { "file/to/cache" =>
      #   [ { line_code: "a5cc2925ca8258af241be7e5b0381edf30266302_19_19",
      #       rich_text: " <span id=\"LC19\" class=\"line\" lang=\"plaintext\">config/initializers/secret_token.rb</span>\n",
      #       text: " config/initializers/secret_token.rb",
      #       type: nil,
      #       index: 3,
      #       old_pos: 19,
      #       new_pos: 19 }
      #   ] }
      #
      #   ...it will write/update a Redis hash (HSET)
      #
      def write_to_redis_hash(hash)
        Redis::Cache.with do |redis|
          redis.multi do |multi|
            hash.each do |diff_file_id, highlighted_diff_lines_hash|
              multi.hset(key.to_s, diff_file_id, highlighted_diff_lines_hash.to_json)

              # HSETs have to have their expiration date manually updated
              #
              multi.expire(@redis_key, EXPIRATION)
            end
          end
        end
      end

      def read_entire_redis_hash
        Redis::Cache.with do |redis|
          redis.hgetall(key.to_s)
        end
      end

      def read_single_entry_from_redis_hash(diff_file_id)
        Redis::Cache.with do |redis|
          redis.hget(key.to_s, diff_file_id)
        end
      end

      def clear
        cache.delete(key)
      end

      def key
        [diffable, 'highlighted-diff-files', Gitlab::Diff::Line::SERIALIZE_KEYS, diff_options]
      end

      private

      def read_file(diff_file)
        cached_content[diff_file.file_identifier]
      end

      def cache
        @backend
      end

      def cached_content
        @cached_content ||= populate_cached_content
      end

      def populate_cached_content
        if Feature.enabled?(:redis_diff_caching)
          read_entire_redis_hash.transform_values! { |v| v.present? ? JSON.parse(v, symbolize_names: true) : nil }
        else
          cache.read(key) || {}
        end
      end

      def cacheable?(diff_file)
        diffable.present? && diff_file.text? && diff_file.diffable?
      end
    end
  end
end
