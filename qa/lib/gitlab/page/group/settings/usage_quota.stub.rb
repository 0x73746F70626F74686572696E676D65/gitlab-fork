# frozen_string_literal: true

module Gitlab
  module Page
    module Group
      module Settings
        module UsageQuota
          # @note Defined as +link :seats_tab+
          # Clicks +seats_tab+
          def seats_tab
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.seats_tab_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def seats_tab_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_seats_tab
          #   end
          # @return [Boolean] true if the +seats_tab+ element is present on the page
          def seats_tab?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :pipelines_tab+
          # Clicks +pipelines_tab+
          def pipelines_tab
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.pipelines_tab_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def pipelines_tab_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_pipelines_tab
          #   end
          # @return [Boolean] true if the +pipelines_tab+ element is present on the page
          def pipelines_tab?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :buy_ci_minutes+
          # Clicks +buy_ci_minutes+
          def buy_ci_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.buy_ci_minutes_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def buy_ci_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_buy_ci_minutes
          #   end
          # @return [Boolean] true if the +buy_ci_minutes+ element is present on the page
          def buy_ci_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :plan_ci_minutes+
          # @return [String] The text content or value of +plan_ci_minutes+
          def plan_ci_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.plan_ci_minutes_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def plan_ci_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_plan_ci_minutes
          #   end
          # @return [Boolean] true if the +plan_ci_minutes+ element is present on the page
          def plan_ci_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :additional_ci_minutes+
          # @return [String] The text content or value of +additional_ci_minutes+
          def additional_ci_minutes
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.additional_ci_minutes_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def additional_ci_minutes_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_additional_ci_minutes
          #   end
          # @return [Boolean] true if the +additional_ci_minutes+ element is present on the page
          def additional_ci_minutes?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :ci_purchase_successful_alert+
          # @return [String] The text content or value of +ci_purchase_successful_alert+
          def ci_purchase_successful_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.ci_purchase_successful_alert_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def ci_purchase_successful_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_ci_purchase_successful_alert
          #   end
          # @return [Boolean] true if the +ci_purchase_successful_alert+ element is present on the page
          def ci_purchase_successful_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :storage_tab+
          # Clicks +storage_tab+
          def storage_tab
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.storage_tab_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def storage_tab_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_storage_tab
          #   end
          # @return [Boolean] true if the +storage_tab+ element is present on the page
          def storage_tab?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +link :buy_storage+
          # Clicks +buy_storage+
          def buy_storage
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.buy_storage_element).to exist
          #   end
          # @return [Watir::Link] The raw +Link+ element
          def buy_storage_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_buy_storage
          #   end
          # @return [Boolean] true if the +buy_storage+ element is present on the page
          def buy_storage?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :used_storage_message+
          # @return [String] The text content or value of +used_storage_message+
          def used_storage_message
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.used_storage_message_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def used_storage_message_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_used_storage_message
          #   end
          # @return [Boolean] true if the +used_storage_message+ element is present on the page
          def used_storage_message?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :group_usage_message+
          # @return [String] The text content or value of +group_usage_message+
          def group_usage_message
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.group_usage_message_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def group_usage_message_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_group_usage_message
          #   end
          # @return [Boolean] true if the +group_usage_message+ element is present on the page
          def group_usage_message?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :dependency_proxy_usage+
          # @return [String] The text content or value of +dependency_proxy_usage+
          def dependency_proxy_usage
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.dependency_proxy_usage_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def dependency_proxy_usage_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_dependency_proxy_usage
          #   end
          # @return [Boolean] true if the +dependency_proxy_usage+ element is present on the page
          def dependency_proxy_usage?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +span :dependency_proxy_size+
          # @return [String] The text content or value of +dependency_proxy_size+
          def dependency_proxy_size
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.dependency_proxy_size_element).to exist
          #   end
          # @return [Watir::Span] The raw +Span+ element
          def dependency_proxy_size_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_dependency_proxy_size
          #   end
          # @return [Boolean] true if the +dependency_proxy_size+ element is present on the page
          def dependency_proxy_size?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :container_registry_usage+
          # @return [String] The text content or value of +container_registry_usage+
          def container_registry_usage
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.container_registry_usage_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def container_registry_usage_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_container_registry_usage
          #   end
          # @return [Boolean] true if the +container_registry_usage+ element is present on the page
          def container_registry_usage?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :project_storage_used+
          # @return [String] The text content or value of +project_storage_used+
          def project_storage_used
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.project_storage_used_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def project_storage_used_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_project_storage_used
          #   end
          # @return [Boolean] true if the +project_storage_used+ element is present on the page
          def project_storage_used?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :project+
          # @return [String] The text content or value of +project+
          def project
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.project_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def project_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_project
          #   end
          # @return [Boolean] true if the +project+ element is present on the page
          def project?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :storage_type_legend+
          # @return [String] The text content or value of +storage_type_legend+
          def storage_type_legend
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.storage_type_legend_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def storage_type_legend_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_storage_type_legend
          #   end
          # @return [Boolean] true if the +storage_type_legend+ element is present on the page
          def storage_type_legend?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +span :container_registry_size+
          # @return [String] The text content or value of +container_registry_size+
          def container_registry_size
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.container_registry_size_element).to exist
          #   end
          # @return [Watir::Span] The raw +Span+ element
          def container_registry_size_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_container_registry_size
          #   end
          # @return [Boolean] true if the +container_registry_size+ element is present on the page
          def container_registry_size?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :purchased_usage_total_free+
          # @return [String] The text content or value of +purchased_usage_total_free+
          def purchased_usage_total_free
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.purchased_usage_total_free_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def purchased_usage_total_free_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_purchased_usage_total_free
          #   end
          # @return [Boolean] true if the +purchased_usage_total_free+ element is present on the page
          def purchased_usage_total_free?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +span :purchased_usage_total+
          # @return [String] The text content or value of +purchased_usage_total+
          def purchased_usage_total
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.purchased_usage_total_element).to exist
          #   end
          # @return [Watir::Span] The raw +Span+ element
          def purchased_usage_total_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_purchased_usage_total
          #   end
          # @return [Boolean] true if the +purchased_usage_total+ element is present on the page
          def purchased_usage_total?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +div :storage_purchase_successful_alert+
          # @return [String] The text content or value of +storage_purchase_successful_alert+
          def storage_purchase_successful_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.storage_purchase_successful_alert_element).to exist
          #   end
          # @return [Watir::Div] The raw +Div+ element
          def storage_purchase_successful_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_storage_purchase_successful_alert
          #   end
          # @return [Boolean] true if the +storage_purchase_successful_alert+ element is present on the page
          def storage_purchase_successful_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @note Defined as +h2 :storage_available_alert+
          # @return [String] The text content or value of +storage_available_alert+
          def storage_available_alert
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota.storage_available_alert_element).to exist
          #   end
          # @return [Watir::H2] The raw +H2+ element
          def storage_available_alert_element
            # This is a stub, used for indexing. The method is dynamically generated.
          end

          # @example
          #   Gitlab::Page::Group::Settings::UsageQuota.perform do |usage_quota|
          #     expect(usage_quota).to be_storage_available_alert
          #   end
          # @return [Boolean] true if the +storage_available_alert+ element is present on the page
          def storage_available_alert?
            # This is a stub, used for indexing. The method is dynamically generated.
          end
        end
      end
    end
  end
end
