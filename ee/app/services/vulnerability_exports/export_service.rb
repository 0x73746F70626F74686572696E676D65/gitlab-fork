# frozen_string_literal: true

module VulnerabilityExports
  class ExportService
    include ::Gitlab::ExclusiveLeaseHelpers

    LEASE_TTL = 1.hour
    LEASE_NAMESPACE = "vulnerability_exports_export"
    EXPORTERS = {
      'csv' => VulnerabilityExports::Exporters::CsvService
    }.freeze
    BATCH_SIZE = 500

    def self.export(vulnerability_export)
      new(vulnerability_export).export
    end

    def initialize(vulnerability_export)
      self.vulnerability_export = vulnerability_export
    end

    def export
      in_lock(lease_key, ttl: LEASE_TTL) do
        generate_export if vulnerability_export.created?
      end
    end

    private

    attr_accessor :vulnerability_export

    delegate :exportable, :format, to: :vulnerability_export, private: true

    def lease_key
      "#{LEASE_NAMESPACE}:#{vulnerability_export.id}"
    end

    def generate_export
      vulnerability_export.start!
      generate_export_file
      vulnerability_export.finish!
    rescue StandardError
      vulnerability_export.reset_state!
      raise
    ensure
      schedule_export_deletion
    end

    def generate_export_file
      exporter.generate { |f| vulnerability_export.file = f }
      vulnerability_export.file.filename = filename
    end

    def exporter
      EXPORTERS[format].new(vulnerabilities)
    end

    def vulnerabilities
      if exportable.is_a?(Group)
        if Feature.enabled?(:optimized_vulnerability_report_export, exportable)
          group_vulnerabilities_enumerator
        else
          in_operator_optimized_enumerator(::Vulnerability.unscoped, {
            in_operator_optimization_options: {
              array_scope: exportable.all_projects.non_archived.select(:id),
              array_mapping_scope: ::Vulnerability.method(:in_optimization_array_mapping_scope)
            }
          })
        end
      else
        Security::VulnerabilitiesFinder.new(exportable).execute.with_findings_scanner_identifiers_and_notes
      end
    end

    def in_operator_optimized_enumerator(scope, opts = {})
      Enumerator.new do |yielder|
        Gitlab::Pagination::Keyset::Iterator.new(scope: scope, **opts).each_batch(of: BATCH_SIZE) do |records|
          ::Vulnerability
            .id_in(records.pluck_primary_key)
            .with_findings_scanner_identifiers_and_notes
            .each { |preloaded_record| yielder << preloaded_record }
        end
      end
    end

    def group_vulnerabilities_enumerator
      Enumerator.new do |yielder|
        group_vulnerability_reads_iterator.each_batch(of: BATCH_SIZE) do |records|
          ::Vulnerability
            .with_export_entities
            .id_in(records.map(&:vulnerability_id))
            .each { |vulnerability| yielder.yield(vulnerability) }
        end
      end
    end

    def group_vulnerability_reads_iterator
      Gitlab::Pagination::Keyset::Iterator.new(
        scope: exportable.vulnerability_reads(use_traversal_ids: true).unarchived.order_traversal_ids_asc,
        use_union_optimization: false
      )
    end

    def schedule_export_deletion
      VulnerabilityExports::ExportDeletionWorker.perform_in(1.hour, vulnerability_export.id)
    end

    def filename
      [
        exportable.full_path.parameterize,
        '_vulnerabilities_',
        Time.current.utc.strftime('%FT%H%M'),
        '.',
        format
      ].join
    end
  end
end
