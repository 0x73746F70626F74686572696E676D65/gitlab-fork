# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    class CreateVulnerabilityService
      include Gitlab::Utils::StrongMemoize

      # This service creates vulnerabilities for an advisory and affected SBOM components.
      # Continuous vulnerability scans are expensive to perform, so the service tries to
      # handle errors gracefully whenever possible. In other words, if we cannot create a
      # vulnerability for Project A we still attempt to create one for Project B, Project C...Project N.
      #
      # @param advisory [::Gitlab::VulnerabilityScanning::Advisory] :advisory
      # @param affected_components [Array<::Gitlab::VulnerabilityScanning::PossiblyAffectedComponent>]
      #   :affected_components
      #
      # @return [ServiceResponse] The service responds with a success if one or more vulnerabilities were created,
      #   and an error if no vulnerabilities could be created. If successful, the service response payload contains
      #   a `vulnerability_ids` key with the IDs of the new vulnerabilities. In addition, it will always return the
      #   `project_ids_with_upsert` and `project_ids_with_error` arrays fields. These fields contain the IDs of
      #   projects where we successfully upserted a vulnerability and the IDs of the projects where
      #   we encountered an error during creation.
      def self.execute(...)
        new(...).execute
      end

      def initialize(advisory:, affected_components:)
        @advisory = advisory
        @affected_components = affected_components
        @project_ids_with_upsert = Set[]
        @project_ids_with_error = Set[]
      end

      def execute
        if finding_maps.empty?
          return ServiceResponse.success(
            message: "All finding maps filtered out and no vulnerabilities created",
            payload: {
              vulnerability_ids: [],
              project_ids_with_upsert: project_ids_with_upsert.to_a,
              project_ids_with_error: project_ids_with_error.to_a
            })
        end

        vulnerability_ids = ::Security::Ingestion::IngestCvsSliceService.execute(finding_maps)
        ServiceResponse.success(message: "Vulnerabilities were created",
          payload: {
            vulnerability_ids: vulnerability_ids,
            project_ids_with_upsert: project_ids_with_upsert.to_a,
            project_ids_with_error: project_ids_with_error.to_a
          })
      rescue StandardError => error
        process_unrecoverable_error(error)
      end

      private

      attr_reader :advisory, :affected_components, :project_ids_with_upsert, :project_ids_with_error

      def report_scanner
        ::Gitlab::VulnerabilityScanning::SecurityScanner.fabricate
      end

      def scanner_for_project(project)
        ::Gitlab::VulnerabilityScanning::SecurityScanner.find_or_create_for_project!(project)
      end

      def finding_for_affected_component(affected_component)
        purl_type = affected_component.purl_type
        builder = ::Gitlab::VulnerabilityScanning::FindingBuilder.for_purl_type!(purl_type)
        builder.new(
          project: affected_component.project,
          pipeline: affected_component.pipeline,
          scanner: report_scanner,
          sbom_source: affected_component.source,
          advisory: advisory,
          affected_component: affected_component
        ).finding
      rescue ::Gitlab::VulnerabilityScanning::FindingBuilder::Error => error
        process_recoverable_error(error, affected_component.project.id)
        nil
      end

      def finding_maps
        maps = affected_components.filter_map do |affected_component|
          pipeline = affected_component.pipeline

          finding = finding_for_affected_component(affected_component)
          next if finding.nil?

          track_upsert_for_project_id(affected_component.project.id)

          scanner_id = scanner_for_project(affected_component.project).id
          FindingMap.new(pipeline: pipeline, report_finding: finding, scanner_id: scanner_id)
        end

        return [] if maps.empty?

        # We need to deduplicate all finding maps by UUID so that they receive a finding ID.
        # Without this, the Security::Ingestion::Tasks::IngestFindings task will fail to set
        # the finding ID.
        # For full details of issue see https://gitlab.com/gitlab-org/gitlab/-/issues/432870#note_1681011775
        maps.uniq(&:uuid)
      end
      strong_memoize_attr :finding_maps

      def track_upsert_for_project_id(project_id)
        project_ids_with_upsert.add(project_id)
      end

      def process_recoverable_error(error, project_id)
        ::Gitlab::ErrorTracking.track_exception(
          error,
          message: 'Skipping vulnerability creation for an affected component',
          project_id: project_id,
          advisory_xid: advisory.xid,
          source_xid: advisory.source_xid)

        project_ids_with_error.add(project_id)
      end

      def process_unrecoverable_error(error)
        ::Gitlab::ErrorTracking.track_exception(error,
          message: "Continuous vulnerability scanning failed to create vulnerabilities",
          project_ids_with_upsert: project_ids_with_upsert.to_a,
          project_ids_with_error: project_ids_with_error.to_a,
          advisory_xid: advisory.xid,
          source_xid: advisory.source_xid)

        ServiceResponse.error(message: "Vulnerabilities were not created", payload: {
          error: error,
          project_ids_with_upsert: project_ids_with_upsert.to_a,
          project_ids_with_error: project_ids_with_error.to_a
        })
      end
    end
  end
end
