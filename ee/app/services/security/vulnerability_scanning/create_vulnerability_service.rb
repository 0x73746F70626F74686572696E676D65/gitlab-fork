# frozen_string_literal: true

module Security
  module VulnerabilityScanning
    class CreateVulnerabilityService
      include Gitlab::Utils::StrongMemoize

      # This service creates vulnerabilities for an advisory and affected SBOM components.
      # Continuous vulnerability scans are expensive to perform, so the service tries to
      # handle errors gracefully whenever possible. In other words, if we cannot create a
      # vulnerability for Project A we still attempt to create one for Project B, Project C...Project N.
      #
      # @param advisory [::Gitlab::VulnerabilityScanning::Advisory] :advisory
      # @param affected_components [Array<::Gitlab::VulnerabilityScanning::PossiblyAffectedComponent>]
      #   :affected_components
      #
      # @return [ServiceResponse] The service responds with a success if one or more vulnerabilities were created,
      #   and an error if no vulnerabilities could be created. If successful, the service response payload contains
      #   a `vulnerability_ids` key with the IDs of the new vulnerabilities. In addition, it will always return the
      #   `project_ids_with_upsert` and `project_ids_with_error` arrays fields. These fields contain the IDs of
      #   projects where we successfully upserted a vulnerability and the IDs of the projects where
      #   we encountered an error during creation.
      def self.execute(...)
        new(...).execute
      end

      def initialize(advisory:, affected_components:)
        @advisory = advisory
        @affected_components = affected_components
        @project_ids_with_upsert = Set[]
        @project_ids_with_error = Set[]
      end

      def execute
        if finding_maps.empty?
          return ServiceResponse.success(
            message: "All finding maps filtered out and no vulnerabilities created",
            payload: {
              vulnerability_ids: [],
              project_ids_with_upsert: project_ids_with_upsert.to_a,
              project_ids_with_error: project_ids_with_error.to_a
            })
        end

        vulnerability_ids = ::Security::Ingestion::IngestCvsSliceService.execute(finding_maps)

        process_archival_and_traversal_ids_changes

        ServiceResponse.success(message: "Vulnerabilities were created",
          payload: {
            vulnerability_ids: vulnerability_ids,
            project_ids_with_upsert: project_ids_with_upsert.to_a,
            project_ids_with_error: project_ids_with_error.to_a
          })
      rescue StandardError => error
        process_unrecoverable_error(error)
      end

      private

      attr_reader :advisory, :affected_components, :project_ids_with_upsert, :project_ids_with_error

      def report_scanner
        ::Gitlab::VulnerabilityScanning::SecurityScanner.fabricate
      end

      def scanner_for_project(project)
        ::Gitlab::VulnerabilityScanning::SecurityScanner.find_or_create_for_project!(project)
      end

      def finding_for_affected_component(affected_component)
        purl_type = affected_component.purl_type
        builder = ::Gitlab::VulnerabilityScanning::FindingBuilder.for_purl_type!(purl_type)
        builder.new(
          project: affected_component.project,
          pipeline: affected_component.pipeline,
          scanner: report_scanner,
          sbom_source: affected_component.source,
          advisory: advisory,
          affected_component: affected_component
        ).finding
      rescue ::Gitlab::VulnerabilityScanning::FindingBuilder::Error => error
        process_recoverable_error(error, affected_component.project.id)
        nil
      end

      def finding_maps
        maps = affected_components.filter_map do |affected_component|
          pipeline = affected_component.pipeline

          finding = finding_for_affected_component(affected_component)
          next if finding.nil?

          track_upsert_for_project_id(affected_component.project.id)

          scanner_id = scanner_for_project(affected_component.project).id
          FindingMap.new(pipeline: pipeline, report_finding: finding, scanner_id: scanner_id)
        end

        return [] if maps.empty?

        # We need to deduplicate all finding maps by UUID so that they receive a finding ID.
        # Without this, the Security::Ingestion::Tasks::IngestFindings task will fail to set
        # the finding ID.
        # For full details of issue see https://gitlab.com/gitlab-org/gitlab/-/issues/432870#note_1681011775
        maps.uniq(&:uuid)
      end
      strong_memoize_attr :finding_maps

      def track_upsert_for_project_id(project_id)
        project_ids_with_upsert.add(project_id)
      end

      def process_recoverable_error(error, project_id)
        ::Gitlab::ErrorTracking.track_exception(
          error,
          message: 'Skipping vulnerability creation for an affected component',
          project_id: project_id,
          advisory_xid: advisory.xid,
          source_xid: advisory.source_xid)

        project_ids_with_error.add(project_id)
      end

      def process_unrecoverable_error(error)
        ::Gitlab::ErrorTracking.track_exception(error,
          message: "Continuous vulnerability scanning failed to create vulnerabilities",
          project_ids_with_upsert: project_ids_with_upsert.to_a,
          project_ids_with_error: project_ids_with_error.to_a,
          advisory_xid: advisory.xid,
          source_xid: advisory.source_xid)

        ServiceResponse.error(message: "Vulnerabilities were not created", payload: {
          error: error,
          project_ids_with_upsert: project_ids_with_upsert.to_a,
          project_ids_with_error: project_ids_with_error.to_a
        })
      end

      def process_archival_and_traversal_ids_changes
        schedule_updating_archived_status_if_needed
        schedule_updating_traversal_ids_if_needed
      end

      def schedule_updating_archived_status_if_needed
        return unless map_of_projects_to_adjust[:archival_updated].present?

        Vulnerabilities::UpdateArchivedAttributeOfVulnerabilityReadsWorker.bulk_perform_async_with_contexts(
          map_of_projects_to_adjust[:archival_updated],
          arguments_proc: ->(project) { project.id },
          context_proc: ->(project) { { project: project } }
        )
      end

      def schedule_updating_traversal_ids_if_needed
        return unless map_of_projects_to_adjust[:traversal_ids_updated].present?

        Vulnerabilities::UpdateNamespaceIdsOfVulnerabilityReadsWorker.bulk_perform_async_with_contexts(
          map_of_projects_to_adjust[:traversal_ids_updated],
          arguments_proc: ->(project) { project.id },
          context_proc: ->(project) { { project: project } }
        )
      end

      def map_of_projects_to_adjust
        @map_of_projects_to_adjust ||= projects.each_with_object(Hash.new { |h, k| h[k] = [] }) do |project, map|
          project_with_most_recent_changes = projects_with_most_recent_changes.find { |p| p == project }

          add_into_archival_updated_list_if_needed(map, project, project_with_most_recent_changes)
          add_into_traversal_ids_updated_list_if_needed(map, project, project_with_most_recent_changes)
        end
      end

      def add_into_archival_updated_list_if_needed(map, project, project_with_most_recent_changes)
        return if project.archived == project_with_most_recent_changes.archived

        map[:archival_updated] << project
      end

      def add_into_traversal_ids_updated_list_if_needed(map, project, project_with_most_recent_changes)
        return if project.namespace.traversal_ids == project_with_most_recent_changes.namespace.traversal_ids

        map[:traversal_ids_updated] << project
      end

      def projects_with_most_recent_changes
        @projects_with_most_recent_changes ||= Project.id_in(project_ids).with_namespace.to_a
      end

      def project_ids
        projects.map(&:id)
      end

      def projects
        @projects ||= affected_components.map(&:project)
      end
    end
  end
end
