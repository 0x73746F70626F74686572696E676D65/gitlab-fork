# frozen_string_literal: true

module MergeRequests
  class CreateFromVulnerabilityDataService < ::BaseService
    def initialize(project, vulnerability, user = nil, params = {})
      super(project, user, params)

      @vulnerability = vulnerability

      # rubocop: disable CodeReuse/Presenter -- Presenter methods are used in ERB presentation.
      @finding_presenter = Vulnerabilities::FindingPresenter.new(@vulnerability.finding)
      # rubocop: enable CodeReuse/Presenter
    end

    def execute
      title_slug = Gitlab::Utils.slugify(finding_presenter.name || "")
      source_branch = "remediate/%s-%s" % [
        title_slug[0..74],
        Time.current.strftime("D%Y%m%dT%H%M%S")
      ]
      target_branch = params[:target_branch] || project.default_branch

      return error("User is not permitted to create merge request") unless can_create_merge_request?

      if vulnerability.remediations.blank? && llm_patch.blank?
        return error("No remediations available for merge request")
      end

      patch_result = create_patch(vulnerability, source_branch, target_branch)

      return error('Unable to apply patch') unless patch_result[:status] == :success

      merge_request_params = {
        title: "Resolve vulnerability: #{finding_presenter.name}",
        description: render_description(vulnerability),
        source_branch: source_branch,
        target_branch: target_branch,
        force_remove_source_branch: "1"
      }

      merge_request = MergeRequests::CreateService.new(project: @project, current_user: @current_user, params: merge_request_params).execute

      if merge_request.valid?
        success(merge_request)
      else
        error(merge_request.errors)
      end
    end

    private

    attr_reader :vulnerability, :finding_presenter

    def llm_patch
      @params[:llm_patch]
    end

    # Diffy creates temp files for diffs, creating diff syntax containing the temp filenames. We strip them off
    # and add the contextually appropriate names for the file being modified instead.

    def create_llm_diff
      source_code = finding_presenter.source_code
      fixed_code = finding_presenter.source_code.gsub(finding_presenter.vulnerable_code, llm_patch)

      diff = Diffy::Diff.new(source_code, fixed_code, include_diff_info: true, context: 2).to_s(:text).lines[2..].join
      diff.prepend("+++ b/#{finding_presenter.file}\n")
      diff.prepend("--- a/#{finding_presenter.file}\n")
      diff.prepend("diff --git a/#{finding_presenter.file} b/#{finding_presenter.file}\n")

      diff
    end

    def create_patch(vulnerability, source_branch, target_branch)
      diffs = if llm_patch
                [create_llm_diff]
              else
                vulnerability.remediations.map { |remediation| Base64.decode64(remediation.with_indifferent_access[:diff]) }
              end

      head_commit = project.repository.find_branch(target_branch).dereferenced_target
      new_commit = render_commit(diffs, head_commit, vulnerability)

      commit_patch_params = {
        branch_name: source_branch,
        start_branch: target_branch,
        patches: [
          new_commit
        ]
      }
      Commits::CommitPatchService.new(@project, @current_user, commit_patch_params).execute
    end

    def success(merge_request)
      super(merge_request: merge_request)
    end

    def render_commit(diffs, head_commit, vulnerability)
      git_user = Gitlab::Git::User.from_gitlab(@current_user)

      # This currently applies only the first diff
      render_template(
        file: 'vulnerabilities/remediation',
        formats: :patch,
        locals: {
          diff: diffs.first,
          head_commit: head_commit,
          user: git_user,
          vulnerability: vulnerability
        }
      )
    end

    def render_description(vulnerability)
      render_template(
        file: 'vulnerabilities/merge_request_description',
        formats: :md,
        locals: {
          vulnerability: vulnerability,
          llm_patch: llm_patch,
          finding: finding_presenter,
          resolve_vulnerability_ai_gateway: Feature.enabled?(:resolve_vulnerability_ai_gateway, @project)
        }
      )
    end

    def render_template(file:, locals:, formats:)
      ApplicationController.render(template: file, locals: locals, formats: formats)
    end

    def can_create_merge_request?
      can?(@current_user, :create_merge_request_in, @project) &&
        can?(@current_user, :create_merge_request_from, @project)
    end
  end
end
