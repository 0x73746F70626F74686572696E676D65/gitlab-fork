<script>
import { uniqBy } from 'lodash';
import { logError } from '~/lib/logger';
import getProjectDetailsQuery from '../../graphql/queries/get_project_details.query.graphql';
import getGroupClusterAgentsQuery from '../../graphql/queries/get_group_cluster_agents.query.graphql';

export default {
  props: {
    projectFullPath: {
      type: String,
      required: false,
      default: '',
    },
  },
  apollo: {
    projectDetails: {
      query: getProjectDetailsQuery,
      variables() {
        return {
          projectFullPath: this.projectFullPath,
        };
      },
      skip() {
        return !this.projectFullPath;
      },
      update() {
        return [];
      },
      error(error) {
        logError(error);
      },
      async result(result) {
        if (result.error || !result.data.project) {
          this.$emit('error');
          return;
        }

        const { nameWithNamespace, repository, group, id } = result.data.project;

        const rootRef = repository ? repository.rootRef : null;

        if (!group) {
          // Guard clause: do not attempt to find agents if project does not have a group
          this.$emit('result', {
            id,
            fullPath: this.projectFullPath,
            nameWithNamespace,
            clusterAgents: [],
            rootRef,
          });
          return;
        }

        const groupFullPath = group.fullPath;
        const groupFullPathParts = groupFullPath.split('/') || [];
        const groupPathsFromRoot = groupFullPathParts.map((_, i, arr) =>
          arr.slice(0, i + 1).join('/'),
        );
        const clusterAgentsResponses = await Promise.all(
          groupPathsFromRoot.map(this.fetchClusterAgents),
        );

        const errors = clusterAgentsResponses.filter((response) => response.error);
        if (errors.length > 0) {
          errors.forEach((error) => logError(error.error));
          this.$emit('error');
          return;
        }

        const clusterAgents = clusterAgentsResponses.flatMap((response) => response.result);
        const uniqClusterAgents = uniqBy(clusterAgents, 'value');

        this.$emit('result', {
          id,
          fullPath: this.projectFullPath,
          nameWithNamespace,
          clusterAgents: uniqClusterAgents,
          rootRef,
        });
      },
    },
  },
  methods: {
    async fetchClusterAgents(groupPath) {
      try {
        // noinspection JSCheckFunctionSignatures - TODO: Address in https://gitlab.com/gitlab-org/gitlab/-/issues/437600
        const { data, error } = await this.$apollo.query({
          query: getGroupClusterAgentsQuery,
          variables: { groupPath },
        });

        if (error) {
          // NOTE: It seems to be impossible to have test coverage for this line
          //       with the current version of mock-apollo-client. Any type of
          //       mock error is always thrown and caught below instead of
          //       being returned.
          return { error };
        }

        return {
          result:
            data.group?.clusterAgents?.nodes.map(({ id, name, project }) => ({
              value: id,
              text: `${project.nameWithNamespace} / ${name}`,
            })) || [],
        };
      } catch (error) {
        return { error };
      }
    },
  },
  render() {
    return this.$scopedSlots.default?.();
  },
};
</script>
