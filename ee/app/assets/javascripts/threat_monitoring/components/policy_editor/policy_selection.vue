<script>
import networkIllustration from '@gitlab/svgs/dist/illustrations/network.svg';
import shieldCheckIllustration from '@gitlab/svgs/dist/illustrations/shield-check.svg';
import magnifyingGlassIllustration from '@gitlab/svgs/dist/illustrations/magnifying-glass.svg';
import { GlCard, GlButton, GlSafeHtmlDirective } from '@gitlab/ui';
import { s__, __ } from '~/locale';
import { mergeUrlParams } from '~/lib/utils/url_utility';
import { POLICY_TYPE_COMPONENT_OPTIONS } from '../constants';

const i18n = {
  examples: __('Examples'),
  selectPolicy: s__('SecurityOrchestration|Select policy'),
  networkPolicyTitle: s__('SecurityOrchestration|Network policy'),
  networkPolicyDesc: s__(
    'SecurityOrchestration|Use network policies to create firewall rules for network connections in your Kubernetes cluster.',
  ),
  networkPolicyExample: s__(
    'SecurityOrchestration|Allow all inbound traffic to all pods from all pods on ports 443/TCP.',
  ),
  scanResultPolicyTitle: s__('SecurityOrchestration|Scan result policy'),
  scanResultPolicyDesc: s__(
    'SecurityOrchestration|Use a scan result policy to create rules that ensure security issues are checked before merging a merge request.',
  ),
  scanResultPolicyExample: s__(
    'SecurityOrchestration|If any scanner finds a newly detected critical vulnerability in an open merge request targeting the master branch, then require two approvals from any member of App security.',
  ),
  scanExecutionPolicyTitle: s__('SecurityOrchestration|Scan execution policy'),
  scanExecutionPolicyDesc: s__(
    'SecurityOrchestration|Scan execution policy allow to create rules which forces security scans for particular branches at certain time. Supported types are SAST, DAST, Secret detection, Container scan, License scan, API fuzzing, coverage-guided fuzzing.',
  ),
  scanExecutionPolicyExample: s__(
    'SecurityOrchestration|Run a DAST scan with Scan Profile A and Site Profile A when a pipeline run against the main branch.',
  ),
};

export default {
  components: {
    GlCard,
    GlButton,
  },
  directives: {
    SafeHtml: GlSafeHtmlDirective,
  },
  methods: {
    constructUrl(policyType) {
      return mergeUrlParams({ type: policyType }, window.location.href);
    },
  },
  policies: [
    {
      urlParameter: POLICY_TYPE_COMPONENT_OPTIONS.container.urlParameter,
      title: i18n.networkPolicyTitle,
      description: i18n.networkPolicyDesc,
      example: i18n.networkPolicyExample,
      svg: networkIllustration,
    },
    {
      urlParameter: POLICY_TYPE_COMPONENT_OPTIONS.scanResult.urlParameter,
      title: i18n.scanResultPolicyTitle,
      description: i18n.scanResultPolicyDesc,
      example: i18n.scanResultPolicyExample,
      svg: shieldCheckIllustration,
    },
    {
      urlParameter: POLICY_TYPE_COMPONENT_OPTIONS.scanExecution.urlParameter,
      title: i18n.scanExecutionPolicyTitle,
      description: i18n.scanExecutionPolicyDesc,
      example: i18n.scanExecutionPolicyExample,
      svg: magnifyingGlassIllustration,
    },
  ],
  i18n,
  safeHtmlConfig: { ADD_TAGS: ['use'] },
};
</script>
<template>
  <div
    class="gl-display-grid gl-md-grid-template-columns-2 gl-gap-6"
    data-qa-selector="policy_selection_wizard"
  >
    <gl-card
      v-for="option in $options.policies"
      :key="option.title"
      body-class="gl-p-6 gl-display-flex gl-flex-grow-1"
    >
      <div class="gl-mr-6 gl-text-white">
        <div v-safe-html:[$options.safeHtmlConfig]="option.svg"></div>
      </div>
      <div class="gl-display-flex gl-flex-direction-column">
        <h4 class="gl-mt-0">{{ option.title }}</h4>
        <p>{{ option.description }}</p>
        <h5>{{ $options.i18n.examples }}</h5>
        <p class="gl-flex-grow-1">{{ option.example }}</p>
        <div>
          <gl-button
            variant="confirm"
            :href="constructUrl(option.urlParameter)"
            :data-testid="`select-policy-${option.urlParameter}`"
            >{{ $options.i18n.selectPolicy }}</gl-button
          >
        </div>
      </div>
    </gl-card>
  </div>
</template>
