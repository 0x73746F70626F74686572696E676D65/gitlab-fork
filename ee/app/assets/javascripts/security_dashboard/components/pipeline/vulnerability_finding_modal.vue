<script>
import {
  GlAlert,
  GlSprintf,
  GlCard,
  GlButton,
  GlFormGroup,
  GlFormTextarea,
  GlModal,
  GlTooltipDirective,
  GlSkeletonLoader,
} from '@gitlab/ui';
import { __, s__ } from '~/locale';
import download from '~/lib/utils/downloader';
import { visitUrl } from '~/lib/utils/url_utility';
import { fetchPolicies } from '~/lib/graphql';
import SolutionCard from 'ee/vue_shared/security_reports/components/solution_card_graphql.vue';
import IssueNote from 'ee/vue_shared/security_reports/components/issue_note_graphql.vue';
import { CREATE_MR_ACTION, DOWNLOAD_PATCH_ACTION } from 'ee/vulnerabilities/constants';
import MergeRequestNote from 'ee/vue_shared/security_reports/components/merge_request_note_graphql.vue';
import VulnerabilityDetailsGraphql from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue';
import DismissalNote from 'ee/vue_shared/security_reports/components/dismissal_note.vue';
import SplitButton from 'ee/vue_shared/security_reports/components/split_button.vue';
import EventItem from 'ee/vue_shared/security_reports/components/event_item.vue';
import securityReportFindingQuery from 'ee/security_dashboard/graphql/queries/security_report_finding.query.graphql';
import vulnerabilityExternalIssuesQuery from 'ee/security_dashboard/graphql/queries/vulnerability_external_issues.query.graphql';
import dismissFindingMutation from 'ee/security_dashboard/graphql/mutations/dismiss_finding.mutation.graphql';
import createMergeRequestMutation from 'ee/security_dashboard/graphql/mutations/finding_create_merge_request.mutation.graphql';
import revertFindingToDetectedMutation from 'ee/security_dashboard/graphql/mutations/revert_finding_to_detected.mutation.graphql';
import createIssueMutation from 'ee/security_dashboard/graphql/mutations/finding_create_issue.mutation.graphql';
import createJiraIssueMutation from 'ee/security_dashboard/graphql/mutations/finding_create_jira_issue.mutation.graphql';
import { VULNERABILITY_MODAL_ID } from 'ee/vue_shared/security_reports/components/constants';
import VulnerabilityDismissalReason from './vulnerability_dismissal_reason.vue';

const CREATE_ISSUE_ACTION = {
  name: __('Create issue'),
  tagline: s__('SecurityReports|Investigate this vulnerability by creating an issue'),
  action: 'create-issue',
};

const CREATE_JIRA_ISSUE_ACTION = {
  name: s__('SecurityReports|Create Jira issue'),
  tagline: s__('SecurityReports|Investigate this vulnerability by creating an issue'),
  action: 'create-jira-issue',
  icon: 'external-link',
};

export const STATE_DISMISSED = 'DISMISSED';
export const STATE_DETECTED = 'DETECTED';
export const STATE_RESOLVED = 'RESOLVED';
export const VULNERABILITY_POLLING_INTERVAL = 1000;

export default {
  components: {
    DismissalNote,
    EventItem,
    GlAlert,
    GlSprintf,
    GlCard,
    GlButton,
    GlFormGroup,
    GlFormTextarea,
    GlModal,
    GlSkeletonLoader,
    IssueNote,
    MergeRequestNote,
    SolutionCard,
    SplitButton,
    VulnerabilityDetailsGraphql,
    VulnerabilityDismissalReason,
  },
  directives: {
    GlTooltip: GlTooltipDirective,
  },
  props: {
    findingUuid: {
      type: String,
      required: true,
    },
    pipelineIid: {
      type: Number,
      required: true,
    },
    projectFullPath: {
      type: String,
      required: true,
    },
  },
  data() {
    return {
      projectId: null,
      hasFindingFetchError: false,
      errorMessage: '',
      isUpdatingFindingState: false,
      isEditingDismissal: false,
      isCreatingMergeRequest: false,
      isCreatingIssue: false,
      isCreatingJiraIssue: false,
      isShowingDeleteButtons: false,
      showDismissalInvalidState: false,
      dismissalComment: '',
      dismissalReason: null,
      finding: null,
    };
  },
  apollo: {
    finding: {
      query: securityReportFindingQuery,
      fetchPolicy: fetchPolicies.NETWORK_ONLY,
      variables() {
        return this.queryVariables;
      },
      update(data) {
        return data.project?.pipeline?.securityReportFinding;
      },
      result({ data = {} }) {
        const { project } = data;
        const stateComment = project?.pipeline?.securityReportFinding?.stateComment;
        const dismissalReason = project?.pipeline?.securityReportFinding?.dismissalReason;

        if (project) {
          this.projectId = project.id;
        }

        // if there is an existing comment then this will show it in the text area for editing
        if (stateComment) {
          this.dismissalComment = stateComment;
        }
        if (dismissalReason) {
          this.dismissalReason = dismissalReason.toLowerCase();
        }
      },
      error() {
        this.errorMessage = this.$options.i18n.fetchErrorMessage;
      },
    },
    vulnerabilityExternalIssues: {
      query: vulnerabilityExternalIssuesQuery,
      manual: true,
      variables() {
        return {
          vulnerabilityId: this.vulnerabilityId,
        };
      },
      skip() {
        return !this.vulnerabilityId || !this.isCreatingJiraIssue;
      },
      result({
        data: {
          vulnerability: {
            externalIssueLinks: { nodes },
          },
        },
      }) {
        const [firstExternalIssueLink = {}] = nodes;
        const { externalIssue } = firstExternalIssueLink;

        if (externalIssue?.webUrl) {
          this.isCreatingJiraIssue = false;

          const openedInNewTab = true;
          visitUrl(externalIssue.webUrl, openedInNewTab);
        }
      },
      error() {
        this.isCreatingJiraIssue = false;
        this.errorMessage = this.$options.i18n.createJiraIssueErrorMessage;
      },
    },
  },
  computed: {
    queryVariables() {
      const { projectFullPath, pipelineIid, findingUuid } = this;

      return {
        projectFullPath,
        pipelineIid,
        findingUuid,
      };
    },
    remediation() {
      return this.finding?.remediations?.[0];
    },
    issueLinks() {
      return this.finding?.issueLinks?.nodes || [];
    },
    isFindingResolved() {
      return this.finding?.state === STATE_RESOLVED;
    },
    canDownloadPatch() {
      return this.canCreateMergeRequest && this.remediation?.diff?.length > 0;
    },
    canCreateMergeRequest() {
      return !this.isFindingResolved && !this.mergeRequest && this.remediation;
    },
    showCreateMergeRequestButton() {
      return this.canCreateMergeRequest && this.finding?.vulnerability?.presentOnDefaultBranch;
    },
    canAdminVulnerability() {
      return this.finding?.userPermissions.adminVulnerability;
    },
    canCreateIssue() {
      return this.issueLinks.length < 1 && this.finding?.userPermissions?.createIssue;
    },
    showErrorMessage() {
      return !this.isLoading && Boolean(this.errorMessage);
    },
    showNoFindingMessage() {
      return !this.isLoading && !this.finding;
    },
    isLoading() {
      return this.$apollo.queries.finding.loading;
    },
    isFindingDismissed() {
      return this.finding?.state === STATE_DISMISSED;
    },
    currentUser() {
      const {
        current_user_id: id,
        current_username: username,
        current_user_fullname: name,
      } = window.gon;

      return {
        id,
        name,
        username,
        state: 'active',
      };
    },
    hasJiraVulnerabilityIssueCreationEnabled() {
      return this.finding?.project?.hasJiraVulnerabilityIssueCreationEnabled;
    },
    dismissalProject() {
      const { nameWithNamespace: value, webUrl: url } = this.finding.project;
      return {
        value,
        url,
      };
    },
    dismissalFeedback() {
      if (!this.finding.dismissedAt) {
        return null;
      }

      const { dismissedAt, dismissedBy, stateComment: comment, dismissalReason } = this.finding;

      // dismissedBy can be null in some edge cases for which we still want to properly load
      // the finding modal, see https://gitlab.com/gitlab-org/gitlab/-/issues/435425 for details
      let author = {};
      if (dismissedBy) {
        const { id, name, username, webUrl } = dismissedBy;

        author = {
          id,
          name,
          username,
          webUrl,
        };
      }

      const commentDetails = comment ? { comment_author: author, comment } : null;

      return {
        created_at: dismissedAt,
        author,
        comment_details: commentDetails,
        dismissalReason,
      };
    },
    mutationConfigs() {
      const { i18n } = this.$options;
      return {
        dismiss: {
          mutationName: 'securityFindingDismiss',
          mutation: dismissFindingMutation,
          errorMessage: i18n.dismissErrorMessage,
        },
        revertToDetected: {
          mutationName: 'securityFindingRevertToDetected',
          mutation: revertFindingToDetectedMutation,
          errorMessage: i18n.revertDismissErrorMessage,
        },
      };
    },
    footerActionButtons() {
      const buttons = [];

      if (this.showCreateMergeRequestButton) {
        buttons.push(CREATE_MR_ACTION);
      }

      if (this.canDownloadPatch) {
        buttons.push(DOWNLOAD_PATCH_ACTION);
      }

      if (this.canCreateIssue) {
        if (!this.hasExistingExternalIssue && this.hasJiraVulnerabilityIssueCreationEnabled) {
          buttons.push(CREATE_JIRA_ISSUE_ACTION);
        }

        if (!this.hasJiraVulnerabilityIssueCreationEnabled) {
          buttons.push(CREATE_ISSUE_ACTION);
        }
      }

      return buttons;
    },
    hasExistingExternalIssue() {
      return this.finding?.vulnerability?.externalIssueLinks.nodes.length > 0;
    },
    mergeRequest() {
      return this.finding?.vulnerability?.mergeRequest;
    },
    vulnerabilityId() {
      return this.finding?.vulnerability?.id;
    },
    title() {
      return this.finding ? this.finding.title : this.$options.i18n.fetchErrorTitle;
    },
  },
  methods: {
    handleCommentEsc() {
      this.isEditingDismissal = false;
      // we need to set the focus on the modal so any subsequent esc key presses can get handled by it
      this.$refs.modal.setFocus();
    },
    closeModal() {
      this.$refs.modal.hide();
    },
    deleteDismissalComment() {
      this.dismissalComment = '';
      return this.mutateFinding(this.mutationConfigs.dismiss);
    },
    updateDismissal() {
      if (!this.dismissalReason) {
        this.showDismissalInvalidState = true;
        return false;
      }

      this.showDismissalInvalidState = false;
      return this.mutateFinding({ ...this.mutationConfigs.dismiss, toggledState: STATE_DISMISSED });
    },
    undoDismissal() {
      return this.mutateFinding({
        ...this.mutationConfigs.revertToDetected,
        toggledState: STATE_DETECTED,
      });
    },
    cancelDismissal() {
      this.isEditingDismissal = false;
      this.showDismissalInvalidState = false;
    },
    async mutateFinding({ mutation, mutationName, errorMessage, toggledState }) {
      this.isUpdatingFindingState = true;

      try {
        await this.$apollo.mutate({
          mutation,
          refetchQueries: [securityReportFindingQuery],
          variables: {
            uuid: this.findingUuid,
            comment: this.dismissalComment,
            dismissalReason: this.dismissalReason?.toUpperCase(),
          },
          update: (store, response) => {
            const { errors } = response.data[mutationName];

            if (errors.length > 0) {
              throw new Error(errors[0]);
            }

            if (toggledState) {
              this.$emit(toggledState.toLowerCase());
            }

            this.closeModal();
          },
        });
      } catch {
        this.errorMessage = errorMessage;
      } finally {
        this.isUpdatingFindingState = false;
      }
    },
    async executeMutation({ mutation, variables, errorMessage }) {
      try {
        const { data } = await this.$apollo.mutate({
          mutation,
          variables,
        });

        const firstResponseItem = data[Object.keys(data)[0]];
        const { errors } = firstResponseItem;

        if (errors.length > 0) {
          throw new Error(errors[0]);
        }

        return data;
      } catch {
        this.errorMessage = errorMessage;
        return null;
      }
    },
    async createMergeRequest() {
      this.isCreatingMergeRequest = true;

      const data = await this.executeMutation({
        mutation: createMergeRequestMutation,
        variables: {
          uuid: this.findingUuid,
        },
        errorMessage: s__(
          'SecurityReports|There was an error creating the merge request. Please try again.',
        ),
      });

      if (data) {
        const { mergeRequest } = data.securityFindingCreateMergeRequest;
        visitUrl(mergeRequest.webUrl);
      }

      this.isCreatingMergeRequest = false;
    },
    async createIssue() {
      this.isCreatingIssue = true;

      const data = await this.executeMutation({
        mutation: createIssueMutation,
        variables: {
          findingUuid: this.findingUuid,
          projectId: this.projectId,
        },
        errorMessage: s__(
          'SecurityReports|There was an error creating the issue. Please try again.',
        ),
      });

      if (data) {
        const { webUrl } = data.securityFindingCreateIssue.issue;
        visitUrl(webUrl);
      } else {
        // Stop loader spinner only if mutation did not succeed
        this.isCreatingIssue = false;
      }
    },
    async createJiraIssue() {
      const { vulnerabilityId } = this;

      if (!vulnerabilityId) {
        return;
      }

      const { createJiraIssueErrorMessage } = this.$options.i18n;
      this.isCreatingJiraIssue = true;

      const data = await this.executeMutation({
        mutation: createJiraIssueMutation,
        variables: {
          vulnerabilityId,
        },
        errorMessage: createJiraIssueErrorMessage,
      });

      if (data) {
        // the mutation creates the Jira issue in the background
        // that means we don't get the URL of the created issue straight away but need to poll for it
        this.$apollo.queries.vulnerabilityExternalIssues.startPolling(
          this.$options.VULNERABILITY_POLLING_INTERVAL,
        );
      } else {
        this.isCreatingJiraIssue = false;
      }
    },
    downloadPatch() {
      download({ fileData: this.remediation.diff, fileName: 'remediation.patch' });
    },
  },
  i18n: {
    fetchErrorTitle: __('Error'),
    fetchErrorMessage: s__(
      'SecurityReports|There was an error fetching the finding. Please try again.',
    ),
    // We instruct the user to re-run the pipeline when the finding is not found because there's a bug
    // when using the modal in context of MRs. Findings can still appear in the "MR security widget",
    // after the pipeline has expired. In that case the finding cannot be fetched anymore.
    // After https://gitlab.com/gitlab-org/gitlab/-/issues/390185 is implemented, we can remove
    // this specific error message.
    noFindingErrorMessage: s__(
      `SecurityReports|There was an error fetching the finding. The security report for this pipeline may have expired. To generate a new security report, go the %{boldStart}Pipelines%{boldEnd} tab and run a pipeline.`,
    ),
    dismissErrorMessage: s__(
      'SecurityReports|There was an error dismissing the finding. Please try again.',
    ),
    createJiraIssueErrorMessage: s__(
      'SecurityReports|There was an error creating a Jira issue for the finding. Please try again.',
    ),
    revertDismissErrorMessage: s__('SecurityReports|There was an error reverting the dismissal.'),
    cancel: __('Cancel'),
    confirmDismissal: s__('SecurityReports|Confirm dismissal'),
    dismissFinding: s__('SecurityReports|Dismiss vulnerability'),
    revertDismissFinding: s__('SecurityReports|Undo dismiss'),
    dismissalComment: s__('SecurityReports|Dismissal comment'),
    dismissCommentPlaceholder: s__('SecurityReports|Add a comment or reason for dismissal'),
  },
  VULNERABILITY_MODAL_ID,
  VULNERABILITY_POLLING_INTERVAL,
};
</script>

<template>
  <gl-modal
    ref="modal"
    size="lg"
    :visible="true"
    :title="title"
    :hide-footer="showNoFindingMessage"
    content-class="gl-p-5"
    modal-id="security-finding-modal"
    data-testid="vulnerability-modal-content"
    @hidden="$emit('hidden')"
  >
    <template #modal-header>
      <gl-skeleton-loader
        v-if="isLoading"
        data-testid="title-loading-indicator"
        :width="400"
        :lines="1"
      />
      <h2 v-else class="gl-m-0 gl-font-lg">
        {{ title }}
      </h2>
    </template>

    <div v-if="isLoading" data-testid="content-loading-indicator">
      <!-- this is just a placeholder until the designs have been finalized. Captured in: https://gitlab.com/gitlab-org/gitlab/-/issues/377217 -->
      <!-- the skeleton loaders will also be moved into a separate component so they can be re-used -->
      <gl-skeleton-loader :width="80" :lines="1" />
      <gl-skeleton-loader :width="200" :lines="1" />
    </div>

    <template v-else-if="finding">
      <vulnerability-details-graphql v-bind="finding" />

      <solution-card
        :solution="finding.solution"
        :remediation="remediation"
        :merge-request="mergeRequest"
      />

      <issue-note :issue-links="issueLinks" :project="finding.project" />
      <merge-request-note :merge-request="mergeRequest" :project="finding.project" />

      <gl-card v-if="isFindingDismissed || isEditingDismissal" data-testid="dismissal-edit-section">
        <dismissal-note
          v-if="dismissalFeedback"
          :feedback="dismissalFeedback"
          :is-editing-dismissal="isEditingDismissal"
          :is-showing-delete-buttons="isShowingDeleteButtons"
          :project="dismissalProject"
          :show-dismissal-actions="!isEditingDismissal"
          has-dismissal-reason-support
          @editDismissal="isEditingDismissal = true"
          @showDismissalDeleteButtons="isShowingDeleteButtons = true"
          @hideDismissalDeleteButtons="isShowingDeleteButtons = false"
          @deleteDismissalComment="deleteDismissalComment"
        />
        <event-item
          v-if="!dismissalFeedback && isEditingDismissal"
          :author="currentUser"
          icon-name="cancel"
          icon-class="ci-status-icon-pending"
        />
        <div v-if="isEditingDismissal" class="gl-mt-5 gl-pt-5 gl-border-t">
          <vulnerability-dismissal-reason
            v-model="dismissalReason"
            :show-error="showDismissalInvalidState"
          />
          <gl-form-group
            :label="$options.i18n.dismissalComment"
            label-for="dismissal-comment"
            class="gl-mb-0"
          >
            <gl-form-textarea
              id="dismissal-comment"
              v-model="dismissalComment"
              data-testid="dismissal-comment"
              :placeholder="$options.i18n.dismissCommentPlaceholder"
              @keydown.meta.enter="updateDismissal"
              @keydown.esc.stop.prevent="handleCommentEsc"
            />
          </gl-form-group>
        </div>
      </gl-card>
    </template>

    <gl-alert
      v-if="showErrorMessage"
      variant="danger"
      :dismissible="false"
      data-testid="error-alert"
    >
      {{ errorMessage || $options.i18n.fetchErrorMessage }}
    </gl-alert>

    <gl-alert
      v-else-if="showNoFindingMessage"
      variant="warning"
      :dismissible="false"
      data-testid="no-finding-alert"
    >
      <gl-sprintf :message="$options.i18n.noFindingErrorMessage">
        <template #bold="{ content }"
          ><strong>{{ content }}</strong></template
        >
      </gl-sprintf>
    </gl-alert>

    <template #modal-footer>
      <template v-if="isEditingDismissal">
        <gl-button data-testid="cancel-editing-dismissal" @click="cancelDismissal">
          {{ $options.i18n.cancel }}
        </gl-button>
        <gl-button
          data-testid="save-editing-dismissal"
          variant="confirm"
          :loading="isUpdatingFindingState"
          @click="updateDismissal"
        >
          {{ $options.i18n.confirmDismissal }}
        </gl-button>
      </template>
      <template v-else>
        <gl-button data-testid="cancel-button" @click="closeModal">
          {{ $options.i18n.cancel }}
        </gl-button>
        <template v-if="canAdminVulnerability && isFindingDismissed">
          <gl-button
            data-testid="undo-dismiss-button"
            :loading="isUpdatingFindingState"
            @click="undoDismissal"
          >
            {{ $options.i18n.revertDismissFinding }}
          </gl-button>
        </template>
        <template v-else-if="canAdminVulnerability">
          <gl-button
            data-testid="dismiss-button"
            :loading="isUpdatingFindingState"
            @click="isEditingDismissal = true"
          >
            {{ $options.i18n.dismissFinding }}
          </gl-button>
        </template>
      </template>
      <split-button
        v-if="!isEditingDismissal"
        :buttons="footerActionButtons"
        :loading="isCreatingIssue || isCreatingJiraIssue || isCreatingMergeRequest"
        @create-merge-request="createMergeRequest"
        @download-patch="downloadPatch"
        @create-issue="createIssue"
        @create-jira-issue="createJiraIssue"
      />
    </template>
  </gl-modal>
</template>
