<script>
import {
  GlAlert,
  GlCard,
  GlButton,
  GlButtonGroup,
  GlFormTextarea,
  GlModal,
  GlTooltipDirective,
  GlSkeletonLoader,
} from '@gitlab/ui';
import { __, s__ } from '~/locale';
import download from '~/lib/utils/downloader';
import { visitUrl } from '~/lib/utils/url_utility';
import { fetchPolicies } from '~/lib/graphql';
import SolutionCard from 'ee/vue_shared/security_reports/components/solution_card_graphql.vue';
import IssueNote from 'ee/vue_shared/security_reports/components/issue_note_graphql.vue';
import MergeRequestNote from 'ee/vue_shared/security_reports/components/merge_request_note_graphql.vue';
import VulnerabilityDetailsGraphql from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue';
import DismissalNote from 'ee/vue_shared/security_reports/components/dismissal_note.vue';
import SplitButton from 'ee/vue_shared/security_reports/components/split_button.vue';
import EventItem from 'ee/vue_shared/security_reports/components/event_item.vue';
import securityReportFindingQuery from 'ee/security_dashboard/graphql/queries/security_report_finding.query.graphql';
import vulnerabilityExternalIssuesQuery from 'ee/security_dashboard/graphql/queries/vulnerability_external_issues.query.graphql';
import dismissFindingMutation from 'ee/security_dashboard/graphql/mutations/dismiss_finding.mutation.graphql';
import createMergeRequestMutation from 'ee/security_dashboard/graphql/mutations/finding_create_merge_request.mutation.graphql';
import revertFindingToDetectedMutation from 'ee/security_dashboard/graphql/mutations/revert_finding_to_detected.mutation.graphql';
import createIssueMutation from 'ee/security_dashboard/graphql/mutations/finding_create_issue.mutation.graphql';
import createJiraIssueMutation from 'ee/security_dashboard/graphql/mutations/finding_create_jira_issue.mutation.graphql';
import { updateFindingState } from 'ee/security_dashboard/graphql/cache_updates';
import { VULNERABILITY_MODAL_ID } from 'ee/vue_shared/security_reports/components/constants';

export const STATE_DISMISSED = 'DISMISSED';
export const STATE_DETECTED = 'DETECTED';
export const STATE_RESOLVED = 'RESOLVED';
export const VULNERABILITY_POLLING_INTERVAL = 1000;

export default {
  components: {
    DismissalNote,
    EventItem,
    GlAlert,
    GlCard,
    GlButton,
    GlButtonGroup,
    GlFormTextarea,
    GlModal,
    GlSkeletonLoader,
    IssueNote,
    MergeRequestNote,
    SolutionCard,
    SplitButton,
    VulnerabilityDetailsGraphql,
  },
  directives: {
    GlTooltip: GlTooltipDirective,
  },
  props: {
    findingUuid: {
      type: String,
      required: true,
    },
    pipelineIid: {
      type: Number,
      required: true,
    },
    projectFullPath: {
      type: String,
      required: true,
    },
  },
  data() {
    return {
      projectId: null,
      hasFindingFetchError: false,
      errorMessage: '',
      isUpdatingFindingState: false,
      isCommentingOnDismissal: false,
      isCreatingMergeRequest: false,
      isCreatingIssue: false,
      isCreatingJiraIssue: false,
      isShowingDeleteButtons: false,
      dismissalComment: '',
      finding: null,
    };
  },
  apollo: {
    finding: {
      query: securityReportFindingQuery,
      fetchPolicy: fetchPolicies.NETWORK_ONLY,
      variables() {
        return this.queryVariables;
      },
      update(data) {
        return data.project?.pipeline?.securityReportFinding;
      },
      result({ data = {} }) {
        const { project } = data;
        const stateComment = project?.pipeline?.securityReportFinding?.stateComment;

        if (project) {
          this.projectId = project.id;
        }

        // if there is an existing comment then this will show it in the text area for editing
        if (stateComment) {
          this.dismissalComment = stateComment;
        }
      },
      error() {
        this.errorMessage = this.$options.i18n.fetchErrorMessage;
      },
    },
    vulnerabilityExternalIssues: {
      query: vulnerabilityExternalIssuesQuery,
      manual: true,
      variables() {
        return {
          vulnerabilityId: this.vulnerabilityId,
        };
      },
      skip() {
        return !this.vulnerabilityId || !this.isCreatingJiraIssue;
      },
      result({
        data: {
          vulnerability: {
            externalIssueLinks: { nodes },
          },
        },
      }) {
        const [firstExternalIssueLink = {}] = nodes;
        const { externalIssue } = firstExternalIssueLink;

        if (externalIssue?.webUrl) {
          this.isCreatingJiraIssue = false;

          const openedInNewTab = true;
          visitUrl(externalIssue.webUrl, openedInNewTab);
        }
      },
      error() {
        this.isCreatingJiraIssue = false;
        this.errorMessage = this.$options.i18n.createJiraIssueErrorMessage;
      },
    },
  },
  computed: {
    queryVariables() {
      const { projectFullPath, pipelineIid, findingUuid } = this;

      return {
        projectFullPath,
        pipelineIid,
        findingUuid,
      };
    },
    remediation() {
      return this.finding?.remediations?.[0];
    },
    issueLinks() {
      return this.finding?.issueLinks?.nodes || [];
    },
    isFindingResolved() {
      return this.finding?.state === STATE_RESOLVED;
    },
    canDownloadPatch() {
      return this.canCreateMergeRequest && this.remediation?.diff?.length > 0;
    },
    canCreateMergeRequest() {
      return !this.isFindingResolved && !this.mergeRequest && this.remediation;
    },
    canCreateVulnerabilityFeedback() {
      return this.finding?.vulnerability?.userPermissions?.createVulnerabilityFeedback;
    },
    canCreateIssue() {
      return this.issueLinks.length < 1 && this.canCreateVulnerabilityFeedback;
    },
    showErrorMessage() {
      return !this.isLoading && (Boolean(this.errorMessage) || !this.finding);
    },
    isLoading() {
      return this.$apollo.queries.finding.loading;
    },
    isFindingDismissed() {
      return this.finding?.state === STATE_DISMISSED;
    },
    toggledState() {
      return this.isFindingDismissed ? STATE_DETECTED : STATE_DISMISSED;
    },
    toggledMutationConfig() {
      const mutationConfigsKey = this.isFindingDismissed ? 'revertToDetected' : 'dismiss';
      return this.mutationConfigs[mutationConfigsKey];
    },
    toggledFindingStateMutationConfig() {
      return { ...this.toggledMutationConfig, toggledState: this.toggledState };
    },
    currentUser() {
      const {
        current_user_id: id,
        current_username: username,
        current_user_fullname: name,
      } = window.gon;

      return {
        id,
        name,
        username,
        state: 'active',
      };
    },
    hasJiraVulnerabilityIssueCreationEnabled() {
      return this.finding?.project?.hasJiraVulnerabilityIssueCreationEnabled;
    },
    dismissButtonText() {
      const {
        isFindingDismissed,
        isCommentingOnDismissal,
        $options: { i18n },
      } = this;

      if (isFindingDismissed) {
        return i18n.revertDismissFinding;
      }

      if (isCommentingOnDismissal) {
        return i18n.addCommentAndDismiss;
      }

      return i18n.dismissFinding;
    },
    hasExistingDismissalComment() {
      return Boolean(this.finding?.stateComment);
    },
    dismissalProject() {
      const { nameWithNamespace: value, webUrl: url } = this.finding.project;
      return {
        value,
        url,
      };
    },
    dismissalFeedback() {
      if (!this.finding.dismissedAt) {
        return null;
      }

      const { dismissedAt, dismissedBy, stateComment: comment, dismissalReason } = this.finding;
      const { id, name, username, webUrl } = dismissedBy;

      const author = {
        id,
        name,
        username,
        webUrl,
      };

      const commentDetails = comment ? { comment_author: author, comment } : null;

      return {
        created_at: dismissedAt,
        author,
        comment_details: commentDetails,
        dismissalReason,
      };
    },
    mutationConfigs() {
      const { i18n } = this.$options;
      return {
        dismiss: {
          mutationName: 'securityFindingDismiss',
          mutation: dismissFindingMutation,
          errorMessage: i18n.dismissErrorMessage,
        },
        revertToDetected: {
          mutationName: 'securityFindingRevertToDetected',
          mutation: revertFindingToDetectedMutation,
          errorMessage: i18n.revertDismissErrorMessage,
        },
      };
    },
    footerActionButtons() {
      const buttons = [];

      const MRButton = {
        name: s__('ciReport|Resolve with merge request'),
        tagline: s__('ciReport|Automatically apply the patch in a new branch'),
        loading: this.isCreatingMergeRequest,
        handler: this.createMergeRequest,
        action: 'create-merge-request',
      };
      const downloadButton = {
        name: s__('SecurityReports|Download patch to resolve'),
        tagline: s__('SecurityReports|Download the patch to apply it manually'),
        handler: this.downloadPatch,
        action: 'download-patch',
      };
      const createIssueButton = {
        name: s__('SecurityReports|Create Issue'),
        tagline: s__('SecurityReports|Investigate this vulnerability by creating an issue'),
        loading: this.isCreatingIssue,
        handler: this.createIssue,
        action: 'create-issue',
      };
      const createJiraIssueButton = {
        name: s__('SecurityReports|Create Jira issue'),
        tagline: s__('SecurityReports|Investigate this vulnerability by creating an issue'),
        loading: this.isCreatingJiraIssue,
        handler: this.createJiraIssue,
        action: 'create-jira-issue',
        icon: 'external-link',
      };

      if (this.canCreateMergeRequest) {
        buttons.push(MRButton);
      }

      if (this.canDownloadPatch) {
        buttons.push(downloadButton);
      }

      if (this.canCreateIssue) {
        if (!this.hasExistingExternalIssue && this.hasJiraVulnerabilityIssueCreationEnabled) {
          buttons.push(createJiraIssueButton);
        }

        if (!this.hasJiraVulnerabilityIssueCreationEnabled) {
          buttons.push(createIssueButton);
        }
      }

      return buttons;
    },
    hasExistingExternalIssue() {
      return this.finding?.vulnerability?.externalIssueLinks.nodes.length > 0;
    },
    mergeRequest() {
      return this.finding?.vulnerability?.mergeRequest;
    },
    vulnerabilityId() {
      return this.finding?.vulnerability?.id;
    },
  },
  methods: {
    handleCancel() {
      if (this.isCommentingOnDismissal) {
        this.isCommentingOnDismissal = false;
      } else {
        this.closeModal();
      }
    },
    handleCommentEsc() {
      this.isCommentingOnDismissal = false;
      // we need to set the focus on the modal so any subsequent esc key presses can get handled by it
      this.$refs.modal.setFocus();
    },
    closeModal() {
      this.$refs.modal.hide();
    },
    toggleFindingState() {
      return this.mutateFinding(this.toggledFindingStateMutationConfig);
    },
    deleteDismissalComment() {
      this.dismissalComment = '';
      return this.mutateFinding(this.mutationConfigs.dismiss);
    },
    updateDismissalComment() {
      return this.mutateFinding(this.mutationConfigs.dismiss);
    },
    async mutateFinding({ mutation, mutationName, errorMessage, toggledState }) {
      this.isUpdatingFindingState = true;

      try {
        await this.$apollo.mutate({
          mutation,
          refetchQueries: [securityReportFindingQuery],
          variables: {
            uuid: this.findingUuid,
            comment: this.dismissalComment,
          },
          update: (store, response) => {
            const { errors } = response.data[mutationName];

            if (errors.length > 0) {
              throw new Error(errors[0]);
            }

            updateFindingState({
              state: toggledState || this.finding.state,
              store,
              query: securityReportFindingQuery,
              variables: this.queryVariables,
            });

            if (toggledState) {
              this.$emit(toggledState.toLowerCase());
            }

            this.closeModal();
          },
        });
      } catch {
        this.errorMessage = errorMessage;
      } finally {
        this.isUpdatingFindingState = false;
      }
    },
    async executeMutation({ mutation, variables, errorMessage }) {
      try {
        const { data } = await this.$apollo.mutate({
          mutation,
          variables,
        });

        const firstResponseItem = data[Object.keys(data)[0]];
        const { errors } = firstResponseItem;

        if (errors.length > 0) {
          throw new Error(errors[0]);
        }

        return data;
      } catch {
        this.errorMessage = errorMessage;
        return null;
      }
    },
    async createMergeRequest() {
      this.isCreatingMergeRequest = true;

      const data = await this.executeMutation({
        mutation: createMergeRequestMutation,
        variables: {
          uuid: this.findingUuid,
        },
        errorMessage: s__(
          'SecurityReports|There was an error creating the merge request. Please try again.',
        ),
      });

      if (data) {
        const { mergeRequest } = data.securityFindingCreateMergeRequest;
        visitUrl(mergeRequest.webUrl);
      }

      this.isCreatingMergeRequest = false;
    },
    async createIssue() {
      this.isCreatingIssue = true;

      const data = await this.executeMutation({
        mutation: createIssueMutation,
        variables: {
          findingUuid: this.findingUuid,
          projectId: this.projectId,
        },
        errorMessage: s__(
          'SecurityReports|There was an error creating the issue. Please try again.',
        ),
      });

      if (data) {
        const { webUrl } = data.securityFindingCreateIssue.issue;
        visitUrl(webUrl);
      }

      this.isCreatingIssue = false;
    },
    async createJiraIssue() {
      const { vulnerabilityId } = this;

      if (!vulnerabilityId) {
        return;
      }

      const { createJiraIssueErrorMessage } = this.$options.i18n;
      this.isCreatingJiraIssue = true;

      const data = await this.executeMutation({
        mutation: createJiraIssueMutation,
        variables: {
          vulnerabilityId,
        },
        errorMessage: createJiraIssueErrorMessage,
      });

      if (data) {
        // the mutation creates the Jira issue in the background
        // that means we don't get the URL of the created issue straight away but need to poll for it
        this.$apollo.queries.vulnerabilityExternalIssues.startPolling(
          this.$options.VULNERABILITY_POLLING_INTERVAL,
        );
      }
    },
    downloadPatch() {
      download({ fileData: this.remediation.diff, fileName: 'remediation.patch' });
    },
  },
  i18n: {
    fetchErrorTitle: __('Error'),
    fetchErrorMessage: s__(
      'SecurityReports|There was an error fetching the finding. Please try again.',
    ),
    dismissErrorMessage: s__(
      'SecurityReports|There was an error dismissing the finding. Please try again.',
    ),
    createJiraIssueErrorMessage: s__(
      'SecurityReports|There was an error creating a Jira issue for the finding. Please try again.',
    ),
    revertDismissErrorMessage: s__('SecurityReports|There was an error reverting the dismissal.'),
    cancel: __('Cancel'),
    saveComment: s__('SecurityReports|Save comment'),
    dismissFinding: s__('SecurityReports|Dismiss vulnerability'),
    revertDismissFinding: s__('SecurityReports|Undo dismiss'),
    addCommentAndDismiss: s__('SecurityReports|Add comment & dismiss'),
    dismissCommentPlaceholder: s__('SecurityReports|Add a comment or reason for dismissal'),
  },
  VULNERABILITY_MODAL_ID,
  VULNERABILITY_POLLING_INTERVAL,
};
</script>

<template>
  <gl-modal
    ref="modal"
    size="lg"
    :visible="true"
    content-class="gl-p-5"
    modal-id="security-finding-modal"
    data-testid="vulnerability-modal-content"
    @hidden="$emit('hidden')"
  >
    <template #modal-header>
      <gl-skeleton-loader
        v-if="isLoading"
        data-testid="title-loading-indicator"
        :width="400"
        :lines="1"
      />
      <h2 v-else class="gl-m-0 gl-font-lg">
        {{ finding ? finding.title : $options.i18n.fetchErrorTitle }}
      </h2>
    </template>

    <div v-if="isLoading" data-testid="content-loading-indicator">
      <!-- this is just a placeholder until the designs have been finalized. Captured in: https://gitlab.com/gitlab-org/gitlab/-/issues/377217 -->
      <!-- the skeleton loaders will also be moved into a separate component so they can be re-used -->
      <gl-skeleton-loader :width="80" :lines="1" />
      <gl-skeleton-loader :width="200" :lines="1" />
    </div>

    <template v-else-if="finding">
      <vulnerability-details-graphql v-bind="finding" />

      <solution-card
        :solution="finding.solution"
        :remediation="remediation"
        :merge-request="mergeRequest"
      />

      <issue-note :issue-links="issueLinks" :project="finding.project" />
      <merge-request-note :merge-request="mergeRequest" :project="finding.project" />

      <gl-card
        v-if="isFindingDismissed || isCommentingOnDismissal"
        data-testid="dismissal-comment-section"
      >
        <dismissal-note
          v-if="dismissalFeedback"
          :feedback="dismissalFeedback"
          :is-commenting-on-dismissal="isCommentingOnDismissal"
          :is-showing-delete-buttons="isShowingDeleteButtons"
          :project="dismissalProject"
          :show-dismissal-comment-actions="!hasExistingDismissalComment || !isCommentingOnDismissal"
          @editVulnerabilityDismissalComment="isCommentingOnDismissal = true"
          @showDismissalDeleteButtons="isShowingDeleteButtons = true"
          @hideDismissalDeleteButtons="isShowingDeleteButtons = false"
          @deleteDismissalComment="deleteDismissalComment"
        />
        <event-item
          v-if="!dismissalFeedback && isCommentingOnDismissal"
          :author="currentUser"
          icon-name="cancel"
          icon-class="ci-status-icon-pending"
        />
        <div
          v-if="isCommentingOnDismissal || !hasExistingDismissalComment"
          class="gl-mt-5 gl-pt-5 gl-border-t"
        >
          <gl-form-textarea
            v-model="dismissalComment"
            :autofocus="isCommentingOnDismissal"
            :placeholder="$options.i18n.dismissCommentPlaceholder"
            @focus="isCommentingOnDismissal = true"
            @keydown.meta.enter="toggleFindingState"
            @keydown.esc.stop.prevent="handleCommentEsc"
          />
        </div>
      </gl-card>
    </template>

    <gl-alert v-if="showErrorMessage" variant="danger" :dismissible="false">
      {{ errorMessage || $options.i18n.fetchErrorMessage }}
    </gl-alert>

    <template #modal-footer>
      <div data-testid="footer">
        <template v-if="isFindingDismissed && isCommentingOnDismissal">
          <gl-button data-testid="cancel-editing-comment" @click="isCommentingOnDismissal = false">
            {{ $options.i18n.cancel }}
          </gl-button>
          <gl-button data-testid="save-edited-comment" @click="updateDismissalComment">
            {{ $options.i18n.saveComment }}
          </gl-button>
        </template>
        <template v-else>
          <gl-button data-testid="cancel-button" @click="handleCancel">
            {{ $options.i18n.cancel }}
          </gl-button>
          <gl-button-group>
            <gl-button
              data-testid="dismiss-button"
              :loading="isUpdatingFindingState"
              @click="toggleFindingState"
            >
              {{ dismissButtonText }}
            </gl-button>
            <gl-button
              v-if="!isFindingDismissed && !isCommentingOnDismissal"
              v-gl-tooltip
              data-testid="dismiss-with-comment-button"
              icon="comment"
              :title="$options.i18n.addCommentAndDismiss"
              :aria-label="$options.i18n.addCommentAndDismiss"
              @click="isCommentingOnDismissal = true"
            />
          </gl-button-group>
        </template>
        <split-button
          v-if="footerActionButtons.length > 1"
          :buttons="footerActionButtons"
          data-testid="footer-action-buttons"
          data-qa-selector="resolve_split_button"
          @create-merge-request="createMergeRequest"
          @download-patch="downloadPatch"
        />
        <gl-button
          v-if="footerActionButtons.length === 1"
          :data-testid="`${footerActionButtons[0].action}-button`"
          :loading="isCreatingIssue || isCreatingJiraIssue"
          variant="confirm"
          category="secondary"
          :icon="footerActionButtons[0].icon"
          @click="footerActionButtons[0].handler"
        >
          {{ footerActionButtons[0].name }}
        </gl-button>
      </div>
    </template>
  </gl-modal>
</template>
