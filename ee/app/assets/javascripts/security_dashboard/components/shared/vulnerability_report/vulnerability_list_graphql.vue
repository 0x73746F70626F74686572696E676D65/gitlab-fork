<script>
import { GlLoadingIcon, GlIntersectionObserver, GlKeysetPagination } from '@gitlab/ui';
import { produce } from 'immer';
import createFlash from '~/flash';
import { s__ } from '~/locale';
import glFeatureFlagsMixin from '~/vue_shared/mixins/gl_feature_flags_mixin';
import { convertToSnakeCase } from '~/lib/utils/text_utility';
import { parseBoolean } from '~/lib/utils/common_utils';
import VulnerabilityList from './vulnerability_list.vue';
import { FIELDS } from './constants';

const PAGE_SIZE = 20;

// Deep searches an object for a key called 'vulnerabilities'. If it's not found, it will traverse
// down the object's first property until either it's found, or there's nothing left to search. Note
// that this will only check the first property of any object, not all of them.
const deepFindVulnerabilities = (data) => {
  let currentData = data;

  while (currentData !== undefined && currentData.vulnerabilities === undefined) {
    [currentData] = Object.values(currentData);
  }

  return currentData?.vulnerabilities;
};

export default {
  components: { GlLoadingIcon, GlIntersectionObserver, VulnerabilityList, GlKeysetPagination },
  mixins: [glFeatureFlagsMixin()],
  inject: ['fullPath', 'canViewFalsePositive', 'hasJiraVulnerabilitiesIntegrationEnabled'],
  props: {
    query: {
      type: Object,
      required: true,
    },
    filters: {
      type: Object,
      required: false,
      default: null,
    },
    fields: {
      type: Array,
      required: true,
    },
    showProjectNamespace: {
      type: Boolean,
      required: false,
      default: false,
    },
    portalName: {
      type: String,
      required: true,
    },
  },
  data() {
    return {
      vulnerabilities: [],
      pageInfo: {},
      // The "before" querystring value on page load.
      initialBefore: this.$route.query.before,
    };
  },
  apollo: {
    vulnerabilities: {
      query() {
        return this.query;
      },
      errorPolicy: 'none',
      variables() {
        return {
          fullPath: this.fullPath,
          sort: `${convertToSnakeCase(this.sort.sortBy)}_${this.sort.sortDesc ? 'desc' : 'asc'}`,
          vetEnabled: this.canViewFalsePositive,
          includeExternalIssueLinks: this.hasJiraVulnerabilitiesIntegrationEnabled,
          // If we're using "after" we need to use "first", and if we're using "before" we need to
          // use "last". See this comment for more info:
          // https://gitlab.com/gitlab-org/gitlab/-/merge_requests/79834#note_831878506
          first: this.before ? null : PAGE_SIZE,
          last: this.before ? PAGE_SIZE : null,
          before: this.before,
          after: this.after,
          ...this.filters,
        };
      },
      update(data) {
        const vulnerabilities = deepFindVulnerabilities(data);
        this.pageInfo = vulnerabilities.pageInfo;
        return vulnerabilities.nodes;
      },
      error() {
        createFlash({
          message: s__(
            'SecurityReports|Error fetching the vulnerability list. Please check your network connection and try again.',
          ),
        });
      },
      skip() {
        return !this.filters;
      },
    },
  },
  computed: {
    before: {
      get() {
        // The GraphQL query can only have a "before" or an "after" but not both, so if both are in
        // the querystring, we'll only use "after" and pretend the "before" doesn't exist.
        return this.after ? undefined : this.$route.query.before;
      },
      set(before) {
        // Check if before will change, otherwise Vue Router will throw a "you're navigating to the
        // same route" error.
        if (before !== this.before) {
          this.pushQuerystring({ before, after: undefined });
        }
      },
    },
    after: {
      get() {
        return this.$route.query.after;
      },
      set(after) {
        // Check if after will change, otherwise Vue Router will throw a "you're navigating to the
        // same route" error.
        if (after !== this.after) {
          this.pushQuerystring({ before: undefined, after });
        }
      },
    },
    sort: {
      get() {
        return {
          sortBy: this.$route.query.sortBy || FIELDS.SEVERITY.key,
          sortDesc: this.$route.query.sortDesc ? parseBoolean(this.$route.query.sortDesc) : true,
        };
      },
      set({ sortBy, sortDesc }) {
        this.pushQuerystring({ sortBy, sortDesc });
      },
    },
    // Used to show the infinite scrolling loading spinner.
    isLoadingVulnerabilities() {
      return this.$apollo.queries.vulnerabilities.loading;
    },
    // Used to show the initial skeleton loader.
    shouldShowLoadingSkeleton() {
      return this.shouldUsePagination
        ? this.isLoadingVulnerabilities
        : this.isLoadingVulnerabilities && this.vulnerabilities.length <= 0;
    },
    shouldUsePagination() {
      return this.glFeatures.vulnerabilityReportPagination;
    },
  },
  watch: {
    filters(newFilters, oldFilters) {
      if (this.shouldUsePagination) {
        // The first time the filters are set, it's done by the vulnerability-filters component, so
        // we don't want to reset the paging. Every time after that will be from user interaction.
        if (oldFilters !== null) {
          this.resetPaging();
        }
      } else {
        // Clear out the vulnerabilities so that the skeleton loader is shown.
        this.vulnerabilities = [];
      }
    },
    sort() {
      // Clear out the vulnerabilities so that the skeleton loader is shown.
      this.vulnerabilities = [];
    },
  },
  methods: {
    fetchNextPage() {
      this.$apollo.queries.vulnerabilities.fetchMore({
        variables: { after: this.pageInfo.endCursor },
        updateQuery: (previousResult, { fetchMoreResult }) => {
          return produce(fetchMoreResult, (draftData) => {
            deepFindVulnerabilities(draftData).nodes.unshift(...this.vulnerabilities);
          });
        },
      });
    },
    getNextPage() {
      this.after = this.pageInfo.endCursor || this.before;
    },
    getPrevPage() {
      this.before = this.pageInfo.startCursor || this.after;
    },
    resetPaging() {
      this.before = undefined;
      this.after = undefined;
    },
    pushQuerystring(data) {
      this.$router.push({ query: { ...this.$route.query, ...data } });
    },
  },
};
</script>

<template>
  <div>
    <vulnerability-list
      :is-loading="shouldShowLoadingSkeleton"
      :vulnerabilities="vulnerabilities"
      :fields="fields"
      :sort.sync="sort"
      :should-show-project-namespace="showProjectNamespace"
      :portal-name="portalName"
    />

    <div v-if="shouldUsePagination" class="gl-text-center gl-mt-6">
      <gl-keyset-pagination
        :has-previous-page="pageInfo.hasPreviousPage"
        :has-next-page="pageInfo.hasNextPage"
        :start-cursor="pageInfo.startCursor"
        :end-cursor="pageInfo.endCursor"
        :disabled="isLoadingVulnerabilities"
        @next="getNextPage"
        @prev="getPrevPage"
      />
    </div>

    <gl-intersection-observer v-else-if="pageInfo.hasNextPage" @appear="fetchNextPage">
      <gl-loading-icon v-if="isLoadingVulnerabilities" size="md" />
    </gl-intersection-observer>
  </div>
</template>
