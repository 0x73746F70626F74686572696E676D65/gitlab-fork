# frozen_string_literal: true

# Security::VulnerabilityReadsFinder
#
# Used to filter Vulnerability records for Vulnerabilities API from vulnerability_reads table
#
# Arguments:
#   vulnerable: any object that has a #vulnerabilities method that returns a collection of `Vulnerability`s
#   params: optional! a hash with one or more of the following:
#     project_ids: if `vulnerable` includes multiple projects (like a Group), this filter will restrict
#                   the vulnerabilities returned to those in the group's projects that also match these IDs
#     include_archived_projects: defaulted to `false`. Determines if results will include vulnerabilities
#                                 associated with archived projects
#     image: only return vulnerabilities with these location images
#     report_type: only return vulnerabilities from these report types
#     severity: only return vulnerabilities with these severities
#     state: only return vulnerabilities in these states
#     scanner: only return vulnerabilities with these external_id
#     scanner_id: only return vulnerabilities with these scanner_ids
#     has_resolution: only return vulnerabilities that have resolution
#     has_issues: only return vulnerabilities that have issues linked
#     has_merge_request: only return vulnerabilities that have MR(s) linked
#     cluster_agent_id: only return vulnerabilities with these cluster_agent_ids
#     has_remediations: only return vulnerabilities that have remediations
#     sort: return vulnerabilities ordered by severity_asc or severity_desc

module Security
  class VulnerabilityReadsFinder
    include FinderMethods
    include Gitlab::Utils::StrongMemoize

    FILTER_NONE = 'none'

    def initialize(vulnerable, params = {})
      @params = params
      @vulnerable = vulnerable
      @vulnerability_reads = initial_relation
    end

    def execute
      use_unnested_filters
      filter_archived_projects
      filter_by_projects
      filter_by_image
      filter_by_report_types
      filter_by_severities
      filter_by_states_and_dismissal_reason
      filter_by_scanner_external_id
      filter_by_scanner_ids
      filter_by_resolution
      filter_by_issues
      filter_by_has_merge_request
      filter_by_cluster_agent_id
      filter_by_has_remediations
      filter_by_owasp_top_10

      sort
    end

    private

    attr_reader :params, :vulnerable, :vulnerability_reads

    def initial_relation
      if utilize_denormalized_attributes_for_group_level_vulnerability_reads?
        vulnerable.vulnerability_reads(use_traversal_ids: true)
      else
        vulnerable.vulnerability_reads
      end
    end

    def use_unnested_filters
      return unless use_unnested_filters?

      @vulnerability_reads = vulnerability_reads.use_unnested_filters
    end

    def use_unnested_filters?
      vulnerable.is_a?(Project) || vulnerable.is_a?(Group)
    end

    def filter_archived_projects
      return if params[:include_archived_projects] == true
      return unless vulnerable.is_a?(Group)

      if utilize_denormalized_attributes_for_group_level_vulnerability_reads?
        return @vulnerability_reads = vulnerability_reads.unarchived
      end

      # `filter_by_projects` will handle archived projects
      return if params[:project_id].present?

      @vulnerability_reads = vulnerability_reads.without_archived_projects
    end

    def filter_by_projects
      return unless params[:project_id].present?

      if utilize_denormalized_attributes_for_group_level_vulnerability_reads?
        return @vulnerability_reads = vulnerability_reads.by_projects(params[:project_id])
      end

      @vulnerability_reads = vulnerability_reads.for_projects(
        params[:project_id],
        params[:include_archived_projects]
      )
    end

    def filter_by_report_types
      return unless report_types.present?

      @vulnerability_reads = vulnerability_reads.with_report_types(report_types)
    end

    def filter_by_severities
      return unless severities.present?

      @vulnerability_reads = vulnerability_reads.with_severities(severities)
    end

    def filter_by_states_and_dismissal_reason
      return unless states.present? || params[:dismissal_reason].present?

      @vulnerability_reads = if states.present? && params[:dismissal_reason].present?
                               vulnerability_reads
                                .with_states(states)
                                .or(
                                  vulnerability_reads
                                    .with_states("dismissed")
                                    .with_dismissal_reason(params[:dismissal_reason])
                                )
                             elsif states.present?
                               vulnerability_reads.with_states(states)
                             else
                               vulnerability_reads
                                 .with_states("dismissed")
                                 .with_dismissal_reason(params[:dismissal_reason])
                             end
    end

    def filter_by_owasp_top_10
      return unless params[:owasp_top_10].present? && allow_owasp_top_10_filter?

      return if params[:owasp_top_10].include?(FILTER_NONE) && owasp_top_10_none_filter_disallowed?

      filter_value = filter_by_no_owasp_top_10? ? nil : params[:owasp_top_10]

      @vulnerability_reads = vulnerability_reads.with_owasp_top_10(filter_value)
    end

    def filter_by_scanner_ids
      return unless params[:scanner_id].present?

      @vulnerability_reads = vulnerability_reads.by_scanner_ids(params[:scanner_id])
    end

    def filter_by_scanner_external_id
      return unless params[:scanner].present?

      @vulnerability_reads = vulnerability_reads.with_scanner_external_ids(params[:scanner])
    end

    def filter_by_resolution
      return unless params[:has_resolution].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_resolution(params[:has_resolution])
    end

    def filter_by_issues
      return unless params[:has_issues].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_issues(params[:has_issues])
    end

    def filter_by_has_merge_request
      return unless params[:has_merge_request].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_merge_request(params[:has_merge_request])
    end

    def filter_by_image
      return if vulnerable.is_a?(InstanceSecurityDashboard) || !params[:image].present?

      @vulnerability_reads = vulnerability_reads.with_container_image(params[:image])
    end

    def filter_by_cluster_agent_id
      return unless params[:cluster_agent_id].present?

      # TODO: One background migration to fill casted_cluster_agent_id migration is finished,
      # we can remove this. See: https://gitlab.com/gitlab-org/gitlab/-/merge_requests/89915
      cluster_agent_ids_as_string = Array.wrap(params[:cluster_agent_id]).map(&:to_s)
      @vulnerability_reads = vulnerability_reads.with_cluster_agent_ids(cluster_agent_ids_as_string)
    end

    def filter_by_has_remediations
      return unless params[:has_remediations].in?([true, false])

      @vulnerability_reads = vulnerability_reads.with_remediations(params[:has_remediations])
    end

    def sort
      if utilize_denormalized_attributes_for_group_level_vulnerability_reads?
        @vulnerability_reads.order_by_params_and_traversal_ids(params[:sort])
      else
        @vulnerability_reads.order_by(params[:sort])
      end
    end

    def allow_owasp_top_10_filter?
      return true if vulnerable.is_a?(Project)

      vulnerable.is_a?(Group) && Feature.enabled?(:vulnerability_owasp_top_10_group, vulnerable, type: :wip)
    end

    def filter_by_no_owasp_top_10?
      params[:owasp_top_10].join.downcase == FILTER_NONE
    end

    def owasp_top_10_none_filter_disallowed?
      Feature.disabled?(:owasp_top_10_null_filtering, vulnerable, type: :gitlab_com_derisk)
    end

    def severities
      if utilize_denormalized_attributes_for_group_level_vulnerability_reads? && params[:severity].blank?
        return Vulnerability.severities.keys
      end

      params[:severity]
    end
    strong_memoize_attr :severities

    def report_types
      if utilize_denormalized_attributes_for_group_level_vulnerability_reads? && params[:report_type].blank?
        return Vulnerability.report_types.keys
      end

      params[:report_type]
    end
    strong_memoize_attr :report_types

    def states
      if utilize_denormalized_attributes_for_group_level_vulnerability_reads? && params[:state].blank?
        return Vulnerability.states.keys
      end

      params[:state]
    end
    strong_memoize_attr :states

    def utilize_denormalized_attributes_for_group_level_vulnerability_reads?
      vulnerable.is_a?(Group) &&
        Feature.enabled?(:utilize_denormalized_attributes_for_group_level_vulnerability_reads, vulnerable)
    end
    strong_memoize_attr :utilize_denormalized_attributes_for_group_level_vulnerability_reads?
  end
end
