import { GlSprintf, GlLink } from '@gitlab/ui';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import { REPORT_TYPES_TO_HUMAN_READABLE } from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/constants';
import Details from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue';
import DetailsSection from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/details_section.vue';
import DetailsSectionListItem from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/details_section_list_item.vue';
import SeverityBadge from 'ee/vue_shared/security_reports/components/severity_badge.vue';

const TEST_VULNERABILITY = {
  description: `Bracket object notation with user input is present, this might allow an attacker to access all properties of the object and even it's prototype, leading to possible code execution.`,
  severity: 'HIGH',
  project: {
    name: 'Gitlab.com',
    webUrl: 'http://gitlab.com',
  },
};

describe('ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue', () => {
  let wrapper;

  const createComponent = (options = {}) => {
    wrapper = shallowMountExtended(Details, {
      propsData: {
        ...TEST_VULNERABILITY,
      },
      stubs: {
        GlSprintf,
        DetailsSection,
        DetailsSectionListItem,
      },
      ...options,
    });
  };

  const expectToBeDetailsSection = (sectionWrapper, { heading = '' } = {}) => {
    expect(sectionWrapper.is(DetailsSection)).toBe(true);
    expect(sectionWrapper.props('heading')).toBe(heading);
  };

  const expectOptionalFieldsNotRendering = (optionalFields = []) => {
    it.each(optionalFields)('does not render the optional field: "%s"', (testId) => {
      expect(wrapper.findByTestId(testId).exists()).toBe(false);
    });
  };

  afterEach(() => {
    wrapper.destroy();
  });

  describe('description section', () => {
    beforeEach(createComponent);

    const findDescriptionSection = () => wrapper.findByTestId('description-section');

    it('is a details section with the correct heading', () => {
      expectToBeDetailsSection(findDescriptionSection(), { heading: 'Description' });
    });

    it(`contains the vulnerability's description`, () => {
      expect(findDescriptionSection().text()).toContain(TEST_VULNERABILITY.description);
    });
  });

  describe('main section', () => {
    it('is a details section', () => {
      createComponent();
      expectToBeDetailsSection(wrapper.findByTestId('main-section'));
    });

    describe('default fields', () => {
      beforeEach(createComponent);

      expectOptionalFieldsNotRendering(['report-type-list-item']);

      it('renders the severity with a badge', () => {
        const severity = wrapper.findByTestId('severity-list-item');

        expect(severity.text()).toContain('Severity:');
        expect(severity.findComponent(SeverityBadge).exists()).toBe(true);
      });

      it('renders the project with a link to it', () => {
        const project = wrapper.findByTestId('project-list-item');

        expect(project.text()).toContain('Project:');
        expect(project.findComponent(GlLink).attributes('href')).toBe(
          TEST_VULNERABILITY.project.webUrl,
        );
      });
    });

    describe('optional fields', () => {
      it.each(Object.entries(REPORT_TYPES_TO_HUMAN_READABLE))(
        'renders the report type: %s',
        (reportType, humanReadableReportType) => {
          createComponent({
            propsData: {
              ...TEST_VULNERABILITY,
              reportType,
            },
          });

          expect(wrapper.findByTestId('report-type-list-item').text()).toContain(
            humanReadableReportType,
          );
        },
      );
    });
  });

  describe('location section', () => {
    const findLocationSection = () => wrapper.findByTestId('location-section');

    describe('with no location data', () => {
      beforeEach(createComponent);

      it('does not get rendered', () => {
        expect(findLocationSection().exists()).toBe(false);
      });
    });

    describe('with location data', () => {
      beforeEach(() =>
        createComponent({
          propsData: {
            ...TEST_VULNERABILITY,
            location: {},
          },
        }),
      );

      it('is a details section with the correct heading', () => {
        expectToBeDetailsSection(findLocationSection(), { heading: 'Location' });
      });

      describe('with file information', () => {
        it.each`
          description                          | lineData                        | expectedLineRange
          ${'end line is after start line'}    | ${{ startLine: 0, endLine: 1 }} | ${'0-1'}
          ${'end line is equal to start line'} | ${{ startLine: 1, endLine: 1 }} | ${'1'}
        `(
          `links to the vulnerable file's line range "$expectedLineRange" when $description`,
          ({ lineData, expectedLineRange }) => {
            const location = {
              blobPath: '/project/namespace/-/blob/e3343434/src/js/main.js',
              file: '/src/js/main.js',
              ...lineData,
            };
            createComponent({
              propsData: {
                ...TEST_VULNERABILITY,
                location,
              },
            });

            const { blobPath, file } = location;
            const fileLink = wrapper.findByTestId('location-file-list-item').findComponent(GlLink);

            expect(fileLink.attributes('href')).toBe(`${blobPath}#L${expectedLineRange}`);
            expect(fileLink.text()).toBe(`${file}:${expectedLineRange}`);
          },
        );
      });
    });
  });
});
