import Vue, { nextTick } from 'vue';
import VueApollo from 'vue-apollo';
import { GlIntersectionObserver } from '@gitlab/ui';
import VueRouter from 'vue-router';
import VulnerabilityListGraphql from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list_graphql.vue';
import VulnerabilityList from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list.vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import vulnerabilitiesQuery from 'ee/security_dashboard/graphql/queries/group_vulnerabilities.query.graphql';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import createFlash from '~/flash';
import { FIELDS } from 'ee/security_dashboard/components/shared/vulnerability_report/constants';

jest.mock('~/flash');

Vue.use(VueApollo);
Vue.use(VueRouter);
const router = new VueRouter();

const fullPath = 'path';
const portalName = 'portal-name';
// Sort object used by tests that don't need to care about what the values are.
const SORT_OBJECT = { sortBy: 'state', sortDesc: true };
const DEFAULT_SORT = `${FIELDS.SEVERITY.key}_desc`;

const createVulnerabilitiesRequestHandler = ({ hasNextPage }) =>
  jest.fn().mockResolvedValue({
    data: {
      group: {
        id: 'group-1',
        vulnerabilities: {
          nodes: [],
          pageInfo: {
            __typename: 'PageInfo',
            startCursor: 'abc',
            endCursor: 'def',
            hasNextPage,
            hasPreviousPage: false,
          },
        },
      },
    },
  });

const vulnerabilitiesRequestHandler = createVulnerabilitiesRequestHandler({ hasNextPage: true });

describe('Vulnerability list GraphQL component', () => {
  let wrapper;

  const createWrapper = ({
    vulnerabilitiesHandler = vulnerabilitiesRequestHandler,
    canViewFalsePositive = false,
    showProjectNamespace = false,
    hasJiraVulnerabilitiesIntegrationEnabled = false,
    filters = {},
    fields = [],
  } = {}) => {
    wrapper = shallowMountExtended(VulnerabilityListGraphql, {
      router,
      apolloProvider: createMockApollo([[vulnerabilitiesQuery, vulnerabilitiesHandler]]),
      provide: {
        fullPath,
        canViewFalsePositive,
        hasJiraVulnerabilitiesIntegrationEnabled,
      },
      propsData: {
        query: vulnerabilitiesQuery,
        portalName,
        filters,
        fields,
        showProjectNamespace,
      },
    });
  };

  const findVulnerabilityList = () => wrapper.findComponent(VulnerabilityList);
  const findIntersectionObserver = () => wrapper.findComponent(GlIntersectionObserver);

  afterEach(() => {
    wrapper.destroy();
    vulnerabilitiesRequestHandler.mockClear();
    // Reset querystring.
    if (Object.keys(router.currentRoute.query).length) {
      router.push({ query: undefined });
    }
  });

  describe('vulnerabilities query', () => {
    it('calls the query once with the expected fullPath variable', () => {
      createWrapper();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledTimes(1);
      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ fullPath }),
      );
    });

    it.each([true, false])(
      'calls the query with the expected vetEnabled property when canViewFalsePositive is %s',
      (canViewFalsePositive) => {
        createWrapper({ canViewFalsePositive });

        expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
          expect.objectContaining({ vetEnabled: canViewFalsePositive }),
        );
      },
    );

    it.each([true, false])(
      'calls the query with the expected includeExternalIssueLinks property when hasJiraVulnerabilitiesIntegrationEnabled is %s',
      (hasJiraVulnerabilitiesIntegrationEnabled) => {
        createWrapper({ hasJiraVulnerabilitiesIntegrationEnabled });

        expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            includeExternalIssueLinks: hasJiraVulnerabilitiesIntegrationEnabled,
          }),
        );
      },
    );

    it('does not call the query if filters are not ready', () => {
      createWrapper({ filters: null });

      expect(vulnerabilitiesRequestHandler).not.toHaveBeenCalled();
    });

    it('shows an error message if the query fails', async () => {
      const vulnerabilitiesHandler = jest.fn().mockRejectedValue(new Error());
      createWrapper({ vulnerabilitiesHandler });
      await waitForPromises();

      expect(createFlash).toHaveBeenCalled();
    });
  });

  describe('vulnerability list component', () => {
    it('gets the expected props', async () => {
      const fields = ['abc'];
      const showProjectNamespace = true;
      createWrapper({ fields, showProjectNamespace });

      expect(findVulnerabilityList().props()).toMatchObject({
        shouldShowProjectNamespace: showProjectNamespace,
        fields,
        portalName,
      });
    });

    it('calls the GraphQL query with the expected sort data when the vulnerability list changes the sort', async () => {
      createWrapper();
      vulnerabilitiesRequestHandler.mockClear();
      findVulnerabilityList().vm.$emit('update:sort', SORT_OBJECT);
      await nextTick();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ sort: 'state_desc' }),
      );
    });
  });

  describe('sorting', () => {
    it.each`
      sortBy           | sortDesc | expected
      ${'state'}       | ${true}  | ${'state_desc'}
      ${'detected'}    | ${false} | ${'detected_asc'}
      ${'description'} | ${true}  | ${'description_desc'}
      ${'reportType'}  | ${false} | ${'report_type_asc'}
    `(
      'reads the querystring sort info and calls the GraphQL query with "$expected" for sort',
      ({ sortBy, sortDesc, expected }) => {
        router.push({ query: { sortBy, sortDesc } });
        createWrapper();

        // This is important; we want the sort info to be read from the querystring from the
        // beginning so that the GraphQL request is only done once, instead of starting with the
        // default sort, then immediately reading the querystring value, which will trigger the
        // GraphQL request twice.
        expect(vulnerabilitiesRequestHandler).toHaveBeenCalledTimes(1);
        expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
          expect.objectContaining({ sort: expected }),
        );
      },
    );

    it(`uses the default sort if there's no querystring data`, () => {
      createWrapper();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ sort: DEFAULT_SORT }),
      );
    });

    it('passes the sort data to the vulnerability list', () => {
      router.push({ query: SORT_OBJECT });
      createWrapper();

      expect(findVulnerabilityList().props('sort')).toEqual(SORT_OBJECT);
    });

    it('calls the GraphQL query with the expected sort data when the vulnerability list changes the sort', async () => {
      createWrapper();
      findVulnerabilityList().vm.$emit('update:sort', SORT_OBJECT);
      await nextTick();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ sort: 'state_desc' }),
      );
    });

    it.each`
      sortBy           | sortDesc
      ${'state'}       | ${true}
      ${'detected'}    | ${false}
      ${'description'} | ${true}
      ${'reportType'}  | ${false}
    `(
      'updates the querystring to sortBy = "$sortBy", sortDesc = "$sortDesc" when the vulnerability list changes the sort',
      ({ sortBy, sortDesc }) => {
        createWrapper();
        findVulnerabilityList().vm.$emit('update:sort', { sortBy, sortDesc });

        expect(router.currentRoute.query).toMatchObject({ sortBy, sortDesc: sortDesc.toString() });
      },
    );

    // This test is for when the querystring is changed by the user clicking forward/back in the
    // browser. When a history state is pushed that only changes the querystring, the page does not
    // refresh, so we need to handle the case where the user is stepping through the browser history
    // but no page refresh is done.
    it('calls the GraphQL query with the expected sort data when the querystring is changed', async () => {
      createWrapper();
      router.push({ query: { sortBy: 'state', sortDesc: true } });
      await nextTick();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ sort: 'state_desc' }),
      );
    });
  });

  describe('intersection observer', () => {
    it('is not shown when the vulnerabilities query is loading for the first time', () => {
      createWrapper();

      expect(findIntersectionObserver().exists()).toBe(false);
    });

    it('will fetch more data when the appear event is fired', async () => {
      createWrapper();
      await waitForPromises();
      const spy = jest.spyOn(wrapper.vm.$apollo.queries.vulnerabilities, 'fetchMore');

      findIntersectionObserver().vm.$emit('appear');
      await waitForPromises();

      expect(spy).toHaveBeenCalledTimes(1);
    });

    it('is not shown if there is no next page', async () => {
      createWrapper({
        vulnerabilitiesHandler: createVulnerabilitiesRequestHandler({ hasNextPage: false }),
      });

      await nextTick();

      expect(findIntersectionObserver().exists()).toBe(false);
    });
  });
});
