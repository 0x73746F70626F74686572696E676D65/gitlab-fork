import { createLocalVue } from '@vue/test-utils';
import VueApollo from 'vue-apollo';
import { nextTick } from 'vue';
import { GlIntersectionObserver } from '@gitlab/ui';
import VulnerabilityListGraphql from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list_graphql.vue';
import VulnerabilityList from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list.vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import vulnerabilitiesQuery from 'ee/security_dashboard/graphql/queries/group_vulnerabilities.query.graphql';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import createFlash from '~/flash';

jest.mock('~/flash');

const localVue = createLocalVue();
localVue.use(VueApollo);

const fullPath = 'path';
const portalName = 'portal-name';

const createVulnerabilitiesRequestHandler = ({ hasNextPage }) =>
  jest.fn().mockResolvedValue({
    data: {
      group: {
        id: 'group-1',
        vulnerabilities: {
          nodes: [],
          pageInfo: { endCursor: 'abc', hasNextPage },
        },
      },
    },
  });

const vulnerabilitiesRequestHandler = createVulnerabilitiesRequestHandler({ hasNextPage: true });

describe('Vulnerability list GraphQL component', () => {
  let wrapper;

  const createWrapper = ({
    vulnerabilitiesHandler = vulnerabilitiesRequestHandler,
    canViewFalsePositive = false,
    showProjectNamespace = false,
    hasJiraVulnerabilitiesIntegrationEnabled = false,
    filters = {},
    fields = [],
  } = {}) => {
    wrapper = shallowMountExtended(VulnerabilityListGraphql, {
      localVue,
      apolloProvider: createMockApollo([[vulnerabilitiesQuery, vulnerabilitiesHandler]]),
      provide: {
        fullPath,
        canViewFalsePositive,
        hasJiraVulnerabilitiesIntegrationEnabled,
      },
      propsData: {
        query: vulnerabilitiesQuery,
        portalName,
        filters,
        fields,
        showProjectNamespace,
      },
    });
  };

  const findVulnerabilityList = () => wrapper.findComponent(VulnerabilityList);
  const findIntersectionObserver = () => wrapper.findComponent(GlIntersectionObserver);

  afterEach(() => {
    wrapper.destroy();
    vulnerabilitiesRequestHandler.mockClear();
  });

  describe('vulnerabilities query', () => {
    it('calls the query once with the expected fullPath variable', () => {
      createWrapper();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledTimes(1);
      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ fullPath }),
      );
    });

    it.each([true, false])(
      'calls the query with the expected vetEnabled property when canViewFalsePositive is %s',
      (canViewFalsePositive) => {
        createWrapper({ canViewFalsePositive });

        expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
          expect.objectContaining({ vetEnabled: canViewFalsePositive }),
        );
      },
    );

    it.each([true, false])(
      'calls the query with the expected includeExternalIssueLinks property when hasJiraVulnerabilitiesIntegrationEnabled is %s',
      (hasJiraVulnerabilitiesIntegrationEnabled) => {
        createWrapper({ hasJiraVulnerabilitiesIntegrationEnabled });

        expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
          expect.objectContaining({
            includeExternalIssueLinks: hasJiraVulnerabilitiesIntegrationEnabled,
          }),
        );
      },
    );

    it('does not call the query if filters are not ready', () => {
      createWrapper({ filters: null });

      expect(vulnerabilitiesRequestHandler).not.toHaveBeenCalled();
    });

    it('shows an error message if the query fails', async () => {
      const vulnerabilitiesHandler = jest.fn().mockRejectedValue(new Error());
      createWrapper({ vulnerabilitiesHandler });
      await waitForPromises();

      expect(createFlash).toHaveBeenCalledTimes(2);
    });
  });

  describe('vulnerability list component', () => {
    it('gets the expected props', async () => {
      const fields = ['abc'];
      const showProjectNamespace = true;
      createWrapper({ fields, showProjectNamespace });

      expect(findVulnerabilityList().props()).toMatchObject({
        shouldShowProjectNamespace: showProjectNamespace,
        fields,
        portalName,
      });
    });

    it('calls the vulnerabilities query with the data from the sort-changed event', async () => {
      createWrapper();
      // First call should be undefined, which uses the default sort.
      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ sort: undefined }),
      );

      const sort = 'sort';
      findVulnerabilityList().vm.$emit('sort-changed', sort);
      await nextTick();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(expect.objectContaining({ sort }));
    });
  });

  describe('intersection observer', () => {
    it('is not shown when the vulnerabilities query is loading for the first time', () => {
      createWrapper();

      expect(findIntersectionObserver().exists()).toBe(false);
    });

    it('will fetch more data when the appear event is fired', async () => {
      createWrapper();
      await waitForPromises();
      const spy = jest.spyOn(wrapper.vm.$apollo.queries.vulnerabilities, 'fetchMore');

      findIntersectionObserver().vm.$emit('appear');
      await waitForPromises();

      expect(spy).toHaveBeenCalledTimes(1);
    });

    it('is not shown if there is no next page', async () => {
      createWrapper({
        vulnerabilitiesHandler: createVulnerabilitiesRequestHandler({ hasNextPage: false }),
      });

      await nextTick();

      expect(findIntersectionObserver().exists()).toBe(false);
    });
  });
});
