import { createLocalVue } from '@vue/test-utils';
import VueApollo from 'vue-apollo';
import { nextTick } from 'vue';
import { GlIntersectionObserver } from '@gitlab/ui';
import VulnerabilityList from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_list.vue';
import VulnerabilityReportDevelopment from 'ee/security_dashboard/components/group/vulnerability_report_development.vue';
import VulnerabilityCounts from 'ee/security_dashboard/components/shared/vulnerability_report/vulnerability_counts.vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import countsQuery from 'ee/security_dashboard/graphql/queries/vulnerability_severities_count.query.graphql';
import vulnerabilitiesQuery from 'ee/security_dashboard/graphql/queries/group_vulnerabilities.query.graphql';
import createMockApollo from 'helpers/mock_apollo_helper';
import createFlash from '~/flash';

jest.mock('~/flash');

const localVue = createLocalVue();
localVue.use(VueApollo);

const counts = { critical: 1, high: 2, info: 3, low: 4, medium: 5, unknown: 6 };
const groupFullPath = 'path';

const countsRequestHandler = jest.fn().mockResolvedValue({
  data: {
    group: {
      vulnerabilitySeveritiesCount: counts,
    },
  },
});

const createVulnerabilitiesRequestHandler = ({ hasNextPage }) =>
  jest.fn().mockResolvedValue({
    data: {
      group: {
        vulnerabilities: {
          nodes: [],
          pageInfo: { endCursor: 'abc', hasNextPage },
        },
      },
    },
  });

const vulnerabilitiesRequestHandler = createVulnerabilitiesRequestHandler({ hasNextPage: true });

describe('Vulnerability counts component', () => {
  let wrapper;

  const createWrapper = ({
    countsHandler = countsRequestHandler,
    vulnerabilitiesHandler = vulnerabilitiesRequestHandler,
    canViewFalsePositive = true,
  } = {}) => {
    // Use the default request handlers if they weren't provided.
    const queries = [
      [countsQuery, countsHandler],
      [vulnerabilitiesQuery, vulnerabilitiesHandler],
    ];

    wrapper = shallowMountExtended(VulnerabilityReportDevelopment, {
      localVue,
      apolloProvider: createMockApollo(queries),
      provide: {
        groupFullPath,
        canViewFalsePositive,
        canAdminVulnerability: true,
        hasProjects: true,
      },
    });
  };

  const findVulnerabilityCounts = () => wrapper.findComponent(VulnerabilityCounts);
  const findVulnerabilityList = () => wrapper.findComponent(VulnerabilityList);
  const findIntersectionObserver = () => wrapper.findComponent(GlIntersectionObserver);

  afterEach(() => {
    wrapper.destroy();
    countsRequestHandler.mockClear();
    vulnerabilitiesRequestHandler.mockClear();
  });

  describe('vulnerability counts query', () => {
    it('calls the query once with the expected data', () => {
      createWrapper();

      expect(countsRequestHandler).toHaveBeenCalledTimes(1);
      expect(countsRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({
          isGroup: true,
          fullPath: groupFullPath,
        }),
      );
    });

    it('shows an error message if the query fails', async () => {
      const countsHandler = jest.fn().mockRejectedValue(new Error());
      createWrapper({ countsHandler });
      // Have to wait 2 ticks here, one for the query to finish loading, and one more for the
      // GraphQL error handler to be called.
      await nextTick();
      await nextTick();

      expect(createFlash).toHaveBeenCalledTimes(1);
    });
  });

  describe('vulnerability counts component', () => {
    it('gets the expected isLoading prop from the counts query loading state', async () => {
      createWrapper();
      // The query will be loading until we use nextTick() to give micro-tasks a chance to run.
      expect(findVulnerabilityCounts().props('isLoading')).toBe(true);

      await nextTick();

      expect(findVulnerabilityCounts().props('isLoading')).toBe(false);
    });

    it('gets the expected counts prop', async () => {
      createWrapper();
      await nextTick();

      expect(findVulnerabilityCounts().props('counts')).toMatchObject(counts);
    });
  });

  describe('group vulnerabilities query', () => {
    it('calls the query once with the expected fullPath variable', () => {
      createWrapper();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledTimes(1);
      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ fullPath: groupFullPath }),
      );
    });

    it.each([true, false])(
      'calls the query with the expected vetEnabled property when canViewFalsePositive is %s',
      (canViewFalsePositive) => {
        createWrapper({ canViewFalsePositive });

        expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
          expect.objectContaining({ vetEnabled: canViewFalsePositive }),
        );
      },
    );

    it('shows an error message if the query fails', async () => {
      const vulnerabilitiesHandler = jest.fn().mockRejectedValue(new Error());
      createWrapper({ vulnerabilitiesHandler });
      // Have to wait 2 ticks here, one for the query to finish loading, and one more for the
      // GraphQL error handler to be called.
      await nextTick();
      await nextTick();

      expect(createFlash).toHaveBeenCalledTimes(1);
    });
  });

  describe('vulnerability list component', () => {
    it('gets the expected vulnerabilities prop', async () => {
      createWrapper();
      await nextTick();

      const vulnerabilities = [];
      wrapper.setData({ vulnerabilities });
      await nextTick();

      expect(findVulnerabilityList().props('vulnerabilities')).toBe(vulnerabilities);
    });

    it('calls the vulnerabilities query with the data from the sort-changed event', async () => {
      createWrapper();
      // First call should be undefined, which uses the default sort.
      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(
        expect.objectContaining({ sort: undefined }),
      );

      const sort = 'sort';
      findVulnerabilityList().vm.$emit('sort-changed', sort);
      await nextTick();

      expect(vulnerabilitiesRequestHandler).toHaveBeenCalledWith(expect.objectContaining({ sort }));
    });
  });

  describe('intersection observer', () => {
    it('is not shown when the vulnerabilities query is loading for the first time', () => {
      createWrapper();

      expect(findIntersectionObserver().exists()).toBe(false);
    });

    it('will fetch more data when the appear event is fired', async () => {
      createWrapper();
      await nextTick();
      const spy = jest.spyOn(wrapper.vm.$apollo.queries.vulnerabilities, 'fetchMore');

      findIntersectionObserver().vm.$emit('appear');

      expect(spy).toHaveBeenCalledTimes(1);
    });

    it('is not shown if there is no next page', async () => {
      createWrapper({
        vulnerabilitiesHandler: createVulnerabilitiesRequestHandler({ hasNextPage: false }),
      });
      await nextTick();

      expect(findIntersectionObserver().exists()).toBe(false);
    });
  });
});
