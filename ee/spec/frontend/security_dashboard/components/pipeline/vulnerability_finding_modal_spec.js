import { GlAlert, GlModal } from '@gitlab/ui';
import Vue from 'vue';
import VueApollo from 'vue-apollo';
import waitForPromises from 'helpers/wait_for_promises';
import createMockApollo from 'helpers/mock_apollo_helper';
import { shallowMountExtended, extendedWrapper } from 'helpers/vue_test_utils_helper';
import { stubComponent, RENDER_ALL_SLOTS_TEMPLATE } from 'helpers/stub_component';
import VulnerabilityFindingModal from 'ee/security_dashboard/components/pipeline/vulnerability_finding_modal.vue';
import SolutionCard from 'ee/vue_shared/security_reports/components/solution_card_graphql.vue';
import VulnerabilityDetailsGraphql from 'ee/security_dashboard/components/shared/vulnerability_details_graphql/index.vue';
import securityReportFindingQuery from 'ee/security_dashboard/graphql/queries/security_report_finding.query.graphql';
import dismissFindingMutation from 'ee/security_dashboard/graphql/mutations/dismiss_finding.mutation.graphql';
import {
  getPipelineSecurityReportFindingResponse,
  pipelineSecurityReportFinding,
} from './mock_data';

Vue.use(VueApollo);

const TEST_FINDING = pipelineSecurityReportFinding;
const TEST_PIPELINE_IID = 1;
const TEST_PROJECT_FULL_PATH = 'path/to/my/project';

describe('Vulnerability finding modal', () => {
  let wrapper;

  const createMockApolloProvider = ({
    withFindingFetchError,
    withDismissalMutationError,
    withoutFindingData,
  }) => {
    const response = getPipelineSecurityReportFindingResponse(withoutFindingData);

    const requestHandlers = [
      [
        securityReportFindingQuery,
        withFindingFetchError
          ? jest.fn().mockRejectedValue()
          : jest.fn().mockResolvedValue(response),
      ],
      [
        dismissFindingMutation,
        jest.fn().mockResolvedValue({
          data: {
            securityFindingDismiss: {
              errors: [...(withDismissalMutationError ? ['Error happened'] : [])],
            },
          },
        }),
      ],
    ];

    return createMockApollo(requestHandlers);
  };

  const createWrapper = ({
    withFindingFetchError = false,
    withDismissalMutationError = false,
    withoutFindingData = false,
  } = {}) =>
    shallowMountExtended(VulnerabilityFindingModal, {
      propsData: {
        findingUuid: TEST_FINDING.uuid,
        pipelineIid: TEST_PIPELINE_IID,
        projectFullPath: TEST_PROJECT_FULL_PATH,
      },
      stubs: {
        GlModal: stubComponent(GlModal, {
          template: RENDER_ALL_SLOTS_TEMPLATE,
        }),
      },
      apolloProvider: createMockApolloProvider({
        withFindingFetchError,
        withDismissalMutationError,
        withoutFindingData,
      }),
    });

  const findModal = () => wrapper.findComponent(GlModal);
  const findVulnerabilityDetails = () => wrapper.findComponent(VulnerabilityDetailsGraphql);
  const findSolutionCard = () => wrapper.findComponent(SolutionCard);
  const findErrorAlert = () => wrapper.findComponent(GlAlert);
  const findFooter = () => wrapper.findByTestId('footer');
  const withinFooter = () => extendedWrapper(findFooter());
  const findLoadingIndicators = () => [
    wrapper.findByTestId('title-loading-indicator'),
    wrapper.findByTestId('content-loading-indicator'),
  ];
  const findDismissButton = () => withinFooter().findByTestId('dismiss-button');

  const dismissFinding = () => findDismissButton().vm.$emit('click');

  const expectModalToBeHiddenAfter = async ({ action }) => {
    const modalHideSpy = jest.spyOn(findModal().vm, 'hide');
    expect(modalHideSpy).not.toHaveBeenCalled();

    await action();

    expect(modalHideSpy).toHaveBeenCalled();
  };

  const waitForFindingToBeLoaded = waitForPromises;
  const waitForFindingToBeDismissed = waitForPromises;

  afterEach(() => {
    wrapper.destroy();
  });

  describe('modal instance', () => {
    beforeEach(() => {
      wrapper = createWrapper();
    });

    it('gets passed the correct props', () => {
      expect(findModal().props()).toMatchObject({
        modalId: expect.any(String),
      });
    });

    it('makes the component emit "hide" when the modal gets closed', () => {
      expect(wrapper.emitted('hide')).toBeUndefined();

      findModal().vm.$emit('hidden');

      expect(wrapper.emitted('hide')).toHaveLength(1);
    });

    describe('footer', () => {
      it('renders as expected', () => {
        expect(findFooter().exists()).toBe(true);
      });

      it('contains a "cancel" button that will hide the modal', () => {
        expectModalToBeHiddenAfter({
          action: () => {
            withinFooter().findByTestId('cancel-button').vm.$emit('click');
          },
        });
      });

      it('contains a "dismiss" button', () => {
        expect(findDismissButton().exists()).toBe(true);
      });
    });
  });

  describe('when loading', () => {
    beforeEach(() => {
      wrapper = createWrapper();
    });

    it('does not show an error alert', () => {
      expect(findErrorAlert().exists()).toBe(false);
    });

    it('shows a skeleton loaders', () => {
      findLoadingIndicators().forEach((loadingIndicator) => {
        expect(loadingIndicator.exists()).toBe(true);
      });
    });
  });

  describe('when loaded successfully', () => {
    beforeEach(async () => {
      wrapper = createWrapper();
      await waitForFindingToBeLoaded();
    });

    it('does not show an error alert', () => {
      expect(findErrorAlert().exists()).toBe(false);
    });

    it('does not show skeleton loaders', () => {
      findLoadingIndicators().forEach((loadingIndicator) => {
        expect(loadingIndicator.exists()).toBe(false);
      });
    });

    it(`shows the finding's title within the modal's header`, () => {
      expect(wrapper.findByRole('heading').text()).toBe(TEST_FINDING.title);
    });

    describe('finding details', () => {
      it('displays details about the given vulnerability finding', () => {
        const { description, severity } = TEST_FINDING;

        expect(findVulnerabilityDetails().props()).toMatchObject({
          description,
          severity,
        });
      });
    });

    describe('solution card', () => {
      it('gets passed the correct solution prop', () => {
        expect(findSolutionCard().props('solution')).toBe(TEST_FINDING.solution);
      });
    });
  });

  describe.each([{ withFindingFetchError: true }, { withoutFindingData: true }])(
    'when an error happens - %s',
    (errorContext) => {
      beforeEach(async () => {
        wrapper = createWrapper(errorContext);
        await waitForFindingToBeLoaded();
      });

      it(`shows an error message within the modal's heading`, () => {
        expect(wrapper.findByRole('heading').text()).toBe('Error');
      });

      it('shows an error alert with the correct error message', () => {
        expect(findErrorAlert().text()).toBe(
          'There was an error fetching the finding. Please try again.',
        );
      });
    },
  );

  describe('dismissal', () => {
    describe('success', () => {
      beforeEach(async () => {
        wrapper = createWrapper();
        await waitForFindingToBeLoaded();
      });

      it('sets the finding to be dismissed', async () => {
        expect(findVulnerabilityDetails().props()).toMatchObject({
          state: 'CONFIRMED',
        });

        dismissFinding();
        await waitForFindingToBeDismissed();

        expect(findVulnerabilityDetails().props()).toMatchObject({
          state: 'DISMISSED',
        });
      });

      it('emits "dismissed-finding"', async () => {
        expect(wrapper.emitted('dismissed-finding')).toBeUndefined();

        dismissFinding();
        await waitForFindingToBeDismissed();

        expect(wrapper.emitted('dismissed-finding')).toHaveLength(1);
      });

      it('hides the modal', () => {
        expectModalToBeHiddenAfter({
          action: async () => {
            findDismissButton().vm.$emit('click');
            await waitForFindingToBeDismissed();
          },
        });
      });
    });

    describe('error', () => {
      beforeEach(async () => {
        wrapper = createWrapper({
          withDismissalMutationError: true,
        });
        await waitForFindingToBeLoaded();
      });

      it('shows an message within the error alert when the response contains errors', async () => {
        expect(findErrorAlert().exists()).toBe(false);

        dismissFinding();
        await waitForFindingToBeDismissed();

        expect(findErrorAlert().text()).toBe(
          'There was an error dismissing the finding. Please try again.',
        );
      });
    });
  });
});
