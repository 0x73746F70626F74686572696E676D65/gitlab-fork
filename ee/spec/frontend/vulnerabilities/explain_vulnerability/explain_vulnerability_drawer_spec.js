import VueApollo from 'vue-apollo';
import {
  GlDrawer,
  GlSkeletonLoader,
  GlAlert,
  GlIcon,
  GlBadge,
  GlSprintf,
  GlButton,
} from '@gitlab/ui';
import Vue, { nextTick } from 'vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import ExplainVulnerabilityDrawer from 'ee/vulnerabilities/components/explain_vulnerability/explain_vulnerability_drawer.vue';
import ExplainVulnerabilityUserFeedback from 'ee/vulnerabilities/components/explain_vulnerability/explain_vulnerability_user_feedback.vue';
import aiResponseSubscription from 'ee/graphql_shared/subscriptions/ai_completion_response.subscription.graphql';
import aiActionMutation from 'ee/graphql_shared/mutations/ai_action.mutation.graphql';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import { DRAWER_Z_INDEX } from '~/lib/utils/constants';

Vue.use(VueApollo);

jest.mock('~/rest_api', () => ({
  getMarkdown: ({ text }) => Promise.resolve({ data: { html: text } }),
}));

jest.mock('~/lib/utils/dom_utils', () => ({
  getContentWrapperHeight: () => '123px',
}));

const MOCK_VULNERABILITY = { id: 1 };

describe('Explain Vulnerability Drawer component', () => {
  let wrapper;

  const getMutationResponse = (errors = []) =>
    jest.fn().mockResolvedValue({ data: { aiAction: { errors } } });

  const getSubscriptionResponse = (responseBody = 'response', errors = []) =>
    jest.fn().mockResolvedValue({
      data: {
        aiCompletionResponse: {
          responseBody,
          errors,
          requestId: '123',
          role: 'assistant',
          timestamp: '2021-05-26T14:00:00.000Z',
        },
      },
    });

  const createWrapper = ({
    mutationResponse = getMutationResponse(),
    subscriptionResponse = getSubscriptionResponse(),
    includeSourceCode = false,
  } = {}) => {
    wrapper = shallowMountExtended(ExplainVulnerabilityDrawer, {
      apolloProvider: createMockApollo([
        [aiActionMutation, mutationResponse],
        [aiResponseSubscription, subscriptionResponse],
      ]),
      propsData: { isOpen: false, vulnerability: MOCK_VULNERABILITY, includeSourceCode },
      stubs: { GlDrawer, GlSprintf, GlButton },
    });
  };

  const createWrapperAndOpenDrawer = (params) => {
    createWrapper(params);
    wrapper.setProps({ isOpen: true });
    return nextTick();
  };

  const createWrapperAndWaitForResponse = async (params) => {
    await createWrapperAndOpenDrawer(params);
    return waitForPromises();
  };

  const findSkeletonLoader = () => wrapper.findComponent(GlSkeletonLoader);
  const findUserFeedback = () => wrapper.findComponent(ExplainVulnerabilityUserFeedback);
  const findErrorAlert = () => wrapper.findComponent(GlAlert);
  const findDrawer = () => wrapper.findComponent(GlDrawer);
  const findMarkdownDiv = () => wrapper.findByTestId('markdown');

  beforeEach(() => {
    gon.current_user_id = 1;
  });

  describe('Explain Vulnerability Drawer component', () => {
    it('does not run mutation or subscription when drawer is closed', async () => {
      const mutationResponse = getMutationResponse();
      const subscriptionResponse = getSubscriptionResponse();
      createWrapper({ mutationResponse, subscriptionResponse });
      await waitForPromises();

      expect(mutationResponse).not.toHaveBeenCalled();
      expect(subscriptionResponse).not.toHaveBeenCalled();
    });

    describe('when drawer is open', () => {
      beforeEach(() => createWrapperAndOpenDrawer());

      it('shows the drawer with the expected props', () => {
        expect(findDrawer().props()).toMatchObject({
          headerHeight: '123px',
          headerSticky: true,
          zIndex: DRAWER_Z_INDEX,
        });
      });

      it('shows the tanuki-ai icon', () => {
        expect(findDrawer().findComponent(GlIcon).props('name')).toBe('tanuki-ai');
      });

      it('shows the drawer title', () => {
        expect(findDrawer().text()).toContain('Explain this vulnerability');
      });

      it('shows the experiment label', () => {
        expect(findDrawer().findComponent(GlBadge).props('variant')).toBe('neutral');
      });

      it('shows the drawer subtitle', () => {
        expect(findDrawer().text()).toContain('Response generated by AI');
      });

      it('emits the close event when the drawer is closed', () => {
        findDrawer().vm.$emit('close');

        expect(wrapper.emitted('close')).toHaveLength(1);
      });
    });

    describe('mutation and subscription responses', () => {
      it('shows only the skeleton loader when loading', async () => {
        await createWrapperAndOpenDrawer();

        expect(findSkeletonLoader().exists()).toBe(true);
        expect(findErrorAlert().exists()).toBe(false);
        expect(findMarkdownDiv().exists()).toBe(false);
      });

      it.each`
        type              | mutationResponse                  | subscriptionResponse
        ${'mutation'}     | ${getMutationResponse(['error'])} | ${getSubscriptionResponse('')}
        ${'subscription'} | ${getMutationResponse()}          | ${getSubscriptionResponse('', ['error'])}
      `(
        'shows only an error when the $type response has an error',
        async ({ mutationResponse, subscriptionResponse }) => {
          await createWrapperAndWaitForResponse({ mutationResponse, subscriptionResponse });

          expect(findSkeletonLoader().exists()).toBe(false);
          expect(findMarkdownDiv().exists()).toBe(false);
          expect(findErrorAlert().text()).toMatchInterpolatedText(
            'There was an unexpected error. Please try again.',
          );
          expect(findErrorAlert().props()).toMatchObject({
            variant: 'danger',
            dismissible: false,
          });
        },
      );

      it('shows the AI response', async () => {
        await createWrapperAndWaitForResponse();

        expect(findSkeletonLoader().exists()).toBe(false);
        expect(findErrorAlert().exists()).toBe(false);
        expect(findMarkdownDiv().text()).toBe('response');
      });

      it.each([true, false])(
        'calls the mutation with includeSourceCode: %s',
        async (includeSourceCode) => {
          const mutationResponse = getMutationResponse();
          await createWrapperAndWaitForResponse({ mutationResponse, includeSourceCode });

          expect(mutationResponse).toHaveBeenCalledWith({
            input: {
              explainVulnerability: {
                includeSourceCode,
                resourceId: 'gid://gitlab/Vulnerability/1',
              },
            },
          });
        },
      );
    });

    describe('User feedback component', () => {
      it('shows the user feedback with the expected prop', async () => {
        await createWrapperAndWaitForResponse();

        expect(findUserFeedback().props('vulnerability')).toBe(MOCK_VULNERABILITY);
      });

      it('does not show the user feedback when the response is loading', async () => {
        await createWrapperAndOpenDrawer();

        expect(findSkeletonLoader().exists()).toBe(true);
        expect(findUserFeedback().exists()).toBe(false);
      });

      it.each`
        type              | mutationResponse                  | subscriptionResponse
        ${'mutation'}     | ${getMutationResponse(['error'])} | ${getSubscriptionResponse('')}
        ${'subscription'} | ${getMutationResponse()}          | ${getSubscriptionResponse('', ['error'])}
      `(
        'does not show the user feedback when there is a $type error',
        async ({ mutationResponse, subscriptionResponse }) => {
          await createWrapperAndWaitForResponse({ mutationResponse, subscriptionResponse });

          expect(findErrorAlert().exists()).toBe(true);
          expect(findUserFeedback().exists()).toBe(false);
        },
      );
    });
  });
});
