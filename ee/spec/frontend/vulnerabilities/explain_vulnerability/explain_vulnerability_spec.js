import VueApollo from 'vue-apollo';
import {
  GlDrawer,
  GlSkeletonLoader,
  GlAlert,
  GlCard,
  GlIcon,
  GlBadge,
  GlSprintf,
  GlLink,
} from '@gitlab/ui';
import Vue, { nextTick } from 'vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import { GENIE_CHAT_MODEL_ROLES } from 'ee/ai/constants';
import ExplainVulnerability from 'ee/vulnerabilities/components/explain_vulnerability/explain_vulnerability.vue';
import ExplainVulnerabilityPrompt from 'ee/vulnerabilities/components/explain_vulnerability/explain_vulnerability_prompt.vue';
import UserFeedback from 'ee/vulnerabilities/components/explain_vulnerability/explain_vulnerability_user_feedback.vue';
import aiResponseSubscription from 'ee/graphql_shared/subscriptions/ai_completion_response.subscription.graphql';
import aiActionMutation from 'ee/graphql_shared/mutations/ai_action.mutation.graphql';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import { getMarkdown } from '~/rest_api';

Vue.use(VueApollo);
jest.mock('~/rest_api');
jest.mock('~/lib/utils/dom_utils', () => ({
  getContentWrapperHeight: () => '123px',
}));

const MOCK_VULNERABILITY = {
  id: 1,
  location: {
    file: 'package.json',
  },
  severity: 'high',
  identifiers: [
    {
      name: 'CWE-100',
    },
    {
      name: 'CWE-200',
    },
  ],
};

const subscriptionResponsePartial = {
  requestId: '123',
  role: GENIE_CHAT_MODEL_ROLES.assistant,
  timestamp: '2021-05-26T14:00:00.000Z',
};

describe('Explain Vulnerability component', () => {
  let wrapper;

  const getMutationResponse = (errors = []) =>
    jest.fn().mockResolvedValue({ data: { aiAction: { errors } } });

  const getSubscriptionResponse = (responseBody = 'response', errors = []) =>
    jest.fn().mockResolvedValue({
      data: { aiCompletionResponse: { responseBody, errors, ...subscriptionResponsePartial } },
    });

  const createWrapper = ({
    mutationResponse = getMutationResponse(),
    subscriptionResponse = getSubscriptionResponse(),
    stubs = { GlDrawer },
  } = {}) => {
    wrapper = shallowMountExtended(ExplainVulnerability, {
      apolloProvider: createMockApollo([
        [aiActionMutation, mutationResponse],
        [aiResponseSubscription, subscriptionResponse],
      ]),
      propsData: { vulnerability: MOCK_VULNERABILITY },
      stubs,
    });
  };

  const findTryButton = () => wrapper.findByTestId('try-button');
  const findSkeletonLoader = () => wrapper.findComponent(GlSkeletonLoader);
  const findUserFeedback = () => wrapper.findComponent(UserFeedback);
  const findErrorAlert = () => wrapper.findComponent(GlAlert);
  const findVulnerabilityPrompt = () => wrapper.findComponent(ExplainVulnerabilityPrompt);
  const findDrawer = () => wrapper.findComponent(GlDrawer);
  const findMarkdownDiv = () => wrapper.findByTestId('markdown');

  const clickTryButton = (waitFn = nextTick) => {
    findTryButton().vm.$emit('click');
    return waitFn();
  };

  beforeEach(() => {
    gon.current_user_id = 1;
    getMarkdown.mockImplementation(({ text }) => Promise.resolve({ data: { html: text } }));
  });

  describe('GlCard component', () => {
    beforeEach(createWrapper);

    it('shows the GlCard with the expected title', () => {
      expect(wrapper.findComponent(GlCard).text()).toContain(ExplainVulnerability.i18n.cardTitle);
    });

    it('shows the tanuki-ai icon', () => {
      expect(wrapper.findComponent(GlIcon).props('name')).toBe('tanuki-ai');
    });

    it('shows the experiment badge with expected link', () => {
      const badge = wrapper.findComponent(GlBadge);

      expect(badge.text()).toBe('Experiment');
      expect(badge.attributes('href')).toBe(ExplainVulnerability.experimentDocHref);
      expect(badge.props()).toMatchObject({
        variant: 'neutral',
        size: 'sm',
      });
    });

    it('shows the card body text', () => {
      expect(wrapper.findComponent(GlSprintf).attributes('message')).toBe(
        ExplainVulnerability.i18n.cardText,
      );
    });

    it('shows the link to the feedback issue', () => {
      createWrapper({ stubs: { GlSprintf } });

      expect(wrapper.findComponent(GlLink).attributes('href')).toBe(
        ExplainVulnerability.feedbackIssueHref,
      );
    });

    it('shows the Try it out button', () => {
      expect(findTryButton().text()).toBe('Try it out');
      expect(findTryButton().props()).toMatchObject({
        variant: 'confirm',
        icon: 'tanuki-ai',
      });
    });
  });

  describe('Try it out button', () => {
    beforeEach(createWrapper);

    it('opens the drawer when clicked', async () => {
      await clickTryButton();

      expect(wrapper.findComponent(GlDrawer).props('open')).toBe(true);
    });

    it('is enabled when the drawer is closed', () => {
      expect(findTryButton().props('disabled')).toBe(false);
    });

    it('is disabled when the drawer is open', async () => {
      await clickTryButton();

      expect(findTryButton().props('disabled')).toBe(true);
    });

    it.each`
      phrase           | isLoading
      ${'loading'}     | ${true}
      ${'not loading'} | ${false}
    `('is $phrase when the prompt loading state is $isLoading', async ({ isLoading }) => {
      createWrapper();
      findVulnerabilityPrompt().vm.$emit('loading-state-changed', isLoading);
      await nextTick();

      expect(findTryButton().props('loading')).toBe(isLoading);
    });

    it.each([true, false])(
      'triggers the AiAction mutation with the expected variables for checkbox state: %s',
      async (checkboxState) => {
        const mutationResponse = getMutationResponse();
        createWrapper({ mutationResponse });
        findVulnerabilityPrompt().vm.$emit('checkbox-changed', checkboxState);
        await clickTryButton();

        expect(mutationResponse).toHaveBeenCalledWith({
          input: {
            explainVulnerability: {
              includeSourceCode: checkboxState,
              resourceId: 'gid://gitlab/Vulnerability/1',
            },
          },
        });
      },
    );
  });

  describe('GlDrawer component', () => {
    beforeEach(() => {
      createWrapper();
      clickTryButton();
    });

    it('shows the drawer with the expected props', () => {
      expect(findDrawer().props()).toMatchObject({
        headerHeight: '123px',
        headerSticky: true,
        zIndex: ExplainVulnerability.DRAWER_Z_INDEX,
      });
    });

    it('closes the drawer when the close event is triggered', async () => {
      findDrawer().vm.$emit('close');
      await nextTick();

      expect(findDrawer().props('open')).toBe(false);
    });

    it('shows the tanuki-ai icon', () => {
      expect(findDrawer().findComponent(GlIcon).props('name')).toBe('tanuki-ai');
    });

    it('shows the drawer title', () => {
      expect(findDrawer().text()).toContain(ExplainVulnerability.i18n.drawerTitle);
    });

    it('shows the experiment label', () => {
      expect(findDrawer().findComponent(GlBadge).props('variant')).toBe('neutral');
    });

    it('shows the drawer subtitle', () => {
      expect(findDrawer().text()).toContain(ExplainVulnerability.i18n.drawerSubtitle);
    });

    it('shows only the skeleton loader when loading', () => {
      expect(findSkeletonLoader().exists()).toBe(true);
      expect(findErrorAlert().exists()).toBe(false);
      expect(findMarkdownDiv().exists()).toBe(false);
    });

    it('shows an error when the AI response has errors', async () => {
      createWrapper({
        mutationResponse: getMutationResponse(['error']),
      });
      await clickTryButton(waitForPromises);

      expect(findSkeletonLoader().exists()).toBe(false);
      expect(findMarkdownDiv().exists()).toBe(false);
      expect(findErrorAlert().attributes('message')).toBe(ExplainVulnerability.i18n.errorText);
      expect(findErrorAlert().props()).toMatchObject({
        variant: 'danger',
        dismissible: false,
      });
    });

    it('shows the AI response', async () => {
      await waitForPromises();

      expect(findSkeletonLoader().exists()).toBe(false);
      expect(findErrorAlert().exists()).toBe(false);
      expect(findMarkdownDiv().text()).toBe('response');
    });
  });

  describe('Vulnerability prompt', () => {
    it('shows the vulnerability prompt', () => {
      createWrapper();

      expect(findVulnerabilityPrompt().props()).toMatchObject({
        vulnerabilityGraphqlId: 'gid://gitlab/Vulnerability/1',
        isDrawerOpen: expect.any(Boolean),
      });
    });
  });

  describe('User feedback', () => {
    it('shows the user feedback with the expected event extra information', async () => {
      createWrapper();
      await clickTryButton(waitForPromises);

      expect(findUserFeedback().props('vulnerability')).toMatchObject(MOCK_VULNERABILITY);
    });

    it('does not show the user feedback when the response is loading', async () => {
      createWrapper();
      await clickTryButton();

      expect(findSkeletonLoader().exists()).toBe(true);
      expect(findUserFeedback().exists()).toBe(false);
    });

    it.each`
      type          | response
      ${'request'}  | ${{ mutationResponse: getMutationResponse(['error']), subscriptionResponse: getSubscriptionResponse('') }}
      ${'response'} | ${{ subscriptionResponse: getSubscriptionResponse('', ['error']) }}
    `('does not show the user feedback when there is a $type error', async ({ response }) => {
      createWrapper(response);
      await clickTryButton(waitForPromises);

      expect(findErrorAlert().exists()).toBe(true);
      expect(findUserFeedback().exists()).toBe(false);
    });
  });
});
