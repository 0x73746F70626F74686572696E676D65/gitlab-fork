import VueApollo from 'vue-apollo';
import { GlDrawer, GlSkeletonLoader, GlAlert } from '@gitlab/ui';
import Vue, { nextTick } from 'vue';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import ExplainThisVulnerability from 'ee/vulnerabilities/components/explain_this_vulnerability.vue';
import ExplainVulnerabilityPrompt from 'ee/vulnerabilities/components/explain_vulnerability_prompt.vue';
import UserFeedback from 'ee/vulnerabilities/components/explain_this_vulnerability_user_feedback.vue';
import aiResponseSubscription from 'ee/graphql_shared/subscriptions/ai_completion_response.subscription.graphql';
import aiActionMutation from 'ee/graphql_shared/mutations/ai_action.mutation.graphql';
import createMockApollo from 'helpers/mock_apollo_helper';
import waitForPromises from 'helpers/wait_for_promises';
import { getMarkdown } from '~/rest_api';

Vue.use(VueApollo);
jest.mock('~/rest_api');

const MOCK_VULNERABILITY = {
  id: 1,
  location: {
    file: 'package.json',
  },
  severity: 'high',
  identifiers: [
    {
      name: 'CWE-100',
    },
    {
      name: 'CWE-200',
    },
  ],
};

describe('Explain This Vulnerability component', () => {
  let wrapper;

  const getMutationResponse = (errors = []) =>
    jest.fn().mockResolvedValue({ data: { aiAction: { errors } } });

  const getSubscriptionResponse = (responseBody = 'response', errors = []) =>
    jest.fn().mockResolvedValue({ data: { aiCompletionResponse: { responseBody, errors } } });

  const createWrapper = ({
    mutationResponse = getMutationResponse(),
    subscriptionResponse = getSubscriptionResponse(),
  } = {}) => {
    wrapper = shallowMountExtended(ExplainThisVulnerability, {
      apolloProvider: createMockApollo([
        [aiActionMutation, mutationResponse],
        [aiResponseSubscription, subscriptionResponse],
      ]),
      propsData: { vulnerability: MOCK_VULNERABILITY },
      stubs: { GlDrawer },
    });
  };

  const findTryButton = () => wrapper.findByTestId('try-button');
  const findSkeletonLoader = () => wrapper.findComponent(GlSkeletonLoader);
  const findUserFeedback = () => wrapper.findComponent(UserFeedback);
  const findErrorAlert = () => wrapper.findComponent(GlAlert);
  const findVulnerabilityPrompt = () => wrapper.findComponent(ExplainVulnerabilityPrompt);

  beforeEach(() => {
    gon.current_user_id = 1;
    getMarkdown.mockImplementation(({ text }) => Promise.resolve({ data: { html: text } }));
  });

  describe('Vulnerability prompt', () => {
    it('shows the vulnerability prompt', () => {
      createWrapper();

      expect(findVulnerabilityPrompt().props('vulnerabilityGraphqlId')).toBe(
        'gid://gitlab/Vulnerability/1',
      );
    });
  });

  describe('User feedback', () => {
    it('shows the user feedback with the expected event extra information', async () => {
      createWrapper();
      findTryButton().vm.$emit('click');
      await waitForPromises();

      expect(findUserFeedback().props('vulnerability')).toMatchObject(MOCK_VULNERABILITY);
    });

    it('does not show the user feedback when the response is loading', async () => {
      createWrapper();
      findTryButton().vm.$emit('click');
      await nextTick();

      expect(findSkeletonLoader().exists()).toBe(true);
      expect(findUserFeedback().exists()).toBe(false);
    });

    it.each`
      type          | response
      ${'request'}  | ${{ mutationResponse: getMutationResponse(['error']), subscriptionResponse: getSubscriptionResponse('') }}
      ${'response'} | ${{ subscriptionResponse: getSubscriptionResponse('', ['error']) }}
    `('does not show the user feedback when there is a $type error', async ({ response }) => {
      createWrapper(response);

      findTryButton().vm.$emit('click');
      await waitForPromises();

      expect(findErrorAlert().exists()).toBe(true);
      expect(findUserFeedback().exists()).toBe(false);
    });
  });
});
