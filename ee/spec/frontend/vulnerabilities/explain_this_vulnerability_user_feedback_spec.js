import { GlFormTextarea } from '@gitlab/ui';
import { nextTick } from 'vue';
import Tracking from '~/tracking';
import { FEEDBACK_OPTIONS } from 'ee/ai/constants';
import { shallowMountExtended } from 'helpers/vue_test_utils_helper';
import ExplainThisVulnerabilityUserFeedback from 'ee/vulnerabilities/components/explain_this_vulnerability_user_feedback.vue';

const EVENT_NAME = 'explain_vulnerability';
const MOCK_TRACKING_DATA = {
  action: 'click_button',
  label: 'response_feedback',
  property: FEEDBACK_OPTIONS[0].value,
  extra: { comment: '' },
};

describe('ExplainThisVulnerabilityUserFeedback', () => {
  let wrapper;

  const createComponent = (props = {}) => {
    wrapper = shallowMountExtended(ExplainThisVulnerabilityUserFeedback, {
      propsData: {
        promptLocation: MOCK_TRACKING_DATA.extra.prompt_location,
        ...props,
      },
    });
  };

  const findFeedbackButtons = () => wrapper.findAllByTestId('feedback-button');
  const firstFeedbackButton = () => findFeedbackButtons().at(0);
  const findSubmitButton = () => wrapper.find('[type="submit"]');
  const findTextArea = () => wrapper.findComponent(GlFormTextarea);

  beforeEach(() => {
    jest.spyOn(Tracking, 'event');
  });

  describe('basic structure', () => {
    beforeEach(() => {
      createComponent();
    });

    it('renders buttons based on provided options', () => {
      expect(findFeedbackButtons()).toHaveLength(FEEDBACK_OPTIONS.length);
    });

    it('should render a textarea for the user comment', () => {
      expect(findTextArea().exists()).toBe(true);
    });
  });

  describe('button', () => {
    beforeEach(() => {
      createComponent();
    });

    it('has correct text', () => {
      expect(firstFeedbackButton().text()).toBe(FEEDBACK_OPTIONS[0].title);
    });

    it('receives correct icon prop', () => {
      expect(firstFeedbackButton().props('icon')).toBe(FEEDBACK_OPTIONS[0].icon);
    });
  });

  describe('tracking', () => {
    beforeEach(() => {
      createComponent();
    });

    it('fires tracking event with extra data passed from prop', () => {
      const eventExtraData = { foo: 'bar' };

      createComponent({ eventExtraData });
      firstFeedbackButton().vm.$emit('click');
      findSubmitButton().vm.$emit('click');

      expect(Tracking.event).toHaveBeenCalledWith(
        undefined,
        EVENT_NAME,
        expect.objectContaining({
          extra: expect.objectContaining(eventExtraData),
        }),
      );
    });

    it('fires tracking event when component is destroyed if button was clicked', () => {
      firstFeedbackButton().vm.$emit('click');
      findSubmitButton().vm.$emit('click');

      expect(Tracking.event).toHaveBeenCalledWith(undefined, EVENT_NAME, MOCK_TRACKING_DATA);
    });

    it('fires tracking event when the window is closed', () => {
      firstFeedbackButton().vm.$emit('click');
      findSubmitButton().vm.$emit('click');

      expect(Tracking.event).toHaveBeenCalledWith(undefined, EVENT_NAME, MOCK_TRACKING_DATA);
    });

    it('shows only selected option with disabled state once feedback is provided', async () => {
      const selectedButtonIndex = 2;

      expect(findFeedbackButtons()).toHaveLength(3);

      findFeedbackButtons().at(selectedButtonIndex).vm.$emit('click');
      findSubmitButton().vm.$emit('click');
      await nextTick();

      const savedFeedbackButtons = findFeedbackButtons();
      const savedFeedbackButton = savedFeedbackButtons.at(0);
      expect(savedFeedbackButtons).toHaveLength(1);
      expect(savedFeedbackButtons.exists()).toBe(true);
      expect(savedFeedbackButton.attributes('disabled')).toBeDefined();
      expect(savedFeedbackButton.text()).toBe(FEEDBACK_OPTIONS[selectedButtonIndex].title);
    });
  });

  describe('submit', () => {
    beforeEach(() => {
      createComponent();
    });

    it('should have the submit button disabled initially', () => {
      expect(findSubmitButton().attributes('disabled')).toBeDefined();
    });

    it('enables the submit button once a feedback option is clicked', async () => {
      await firstFeedbackButton().vm.$emit('click');
      expect(findSubmitButton().attributes('disabled')).toBeUndefined();
    });

    it('does not display textarea and submit button after the form is submitted', async () => {
      firstFeedbackButton().vm.$emit('click');
      findSubmitButton().vm.$emit('click');

      await nextTick();

      expect(findTextArea().exists()).toBe(false);
      expect(findSubmitButton().exists()).toBe(false);
    });
  });
});
