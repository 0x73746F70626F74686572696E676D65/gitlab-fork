# frozen_string_literal: true

RSpec.shared_examples 'service account creation success' do
  it 'creates a service account successfully', :aggregate_failures do
    result = service.execute

    expect(result.status).to eq(:success)
    expect(result.payload.confirmed?).to eq(true)
    expect(result.payload.user_type).to eq('service_account')
    expect(result.payload.external).to eq(true)
  end

  include_examples 'username and email pair is generated by Gitlab::Utils::UsernameAndEmailGenerator' do
    subject { service.execute.payload }

    let(:email_domain) { "noreply.#{Gitlab.config.gitlab.host}" }
  end
end

RSpec.shared_examples 'service account tiering check for self-managed' do
  context 'when subscription is of starter plan' do
    let(:license) { create(:license, plan: License::STARTER_PLAN) }

    it 'raises error' do
      result = service.execute

      expect(result.status).to eq(:error)
      expect(result.message).to include('NO_SEATS_AVAILABLE')
    end
  end

  context 'when subscription is ultimate tier' do
    let(:license) { create(:license, plan: License::ULTIMATE_PLAN) }

    it_behaves_like 'service account creation success' do
      let(:username_prefix) { uname_prefix }
    end

    it 'correctly returns active model errors' do
      service = described_class.new(current_user)
      service.execute

      result = service.execute

      expect(result.status).to eq(:error)
      expect(result.message).to eq(error_message)
    end
  end

  context 'when subscription is of premium tier' do
    let(:license) { create(:license, plan: License::PREMIUM_PLAN) }
    let!(:service_account3) { create(:user, :service_account) }
    let!(:service_account4) { create(:user, :service_account) }

    context 'when premium seats are not available' do
      before do
        allow(license).to receive(:restricted_user_count).and_return(1)
      end

      it 'raises error' do
        result = service.execute

        expect(result.status).to eq(:error)
        expect(result.message).to include('NO_SEATS_AVAILABLE')
      end
    end

    context 'when premium seats are available' do
      before do
        allow(license).to receive(:restricted_user_count).and_return(User.service_account.count + 2)
      end

      it_behaves_like 'service account creation success' do
        let(:username_prefix) { uname_prefix }
      end

      it 'correctly returns active model errors' do
        service = described_class.new(current_user)
        service.execute

        result = service.execute

        expect(result.status).to eq(:error)
        expect(result.message).to eq(error_message)
      end
    end
  end
end
