# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::VulnerabilityScanning::AdvisoryScanner, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }
  let_it_be_with_reload(:affected_project) { create(:project) }
  let_it_be(:affected_pipeline) { create(:ci_pipeline, user: user, project: affected_project) }

  let_it_be(:user_2) { create(:user) }
  let_it_be_with_reload(:affected_twice_project) { create(:project) }
  let_it_be(:affected_twice_pipeline) { create(:ci_pipeline, user: user_2, project: affected_twice_project) }

  let_it_be(:invalid_affected_project) { create(:project) }
  # A user is required to attribute vulnerability creation to a user, hence the omission of a user
  # for the pipeline here.
  let_it_be(:invalid_affected_pipeline) { create(:ci_pipeline, project: invalid_affected_project) }

  let_it_be(:unaffected_project) { create(:project) }
  let_it_be(:unaffected_pipeline) { create(:ci_pipeline, user: user, project: unaffected_project) }

  let_it_be(:affected_version) { create(:sbom_component_version, version: '0.8.0') }
  let_it_be(:affected_version_2) { create(:sbom_component_version, version: '0.9.0') }
  let_it_be(:unaffected_version) { create(:sbom_component_version, version: '1.0.0') }

  let(:affected_range) { '>=0.8.0 <1.0.0' }

  let(:affected_package) do
    create(:pm_affected_package, package_name: 'eslint', purl_type: :npm, affected_range: affected_range)
  end

  before_all do
    eslint = create(:sbom_component, name: 'eslint', purl_type: :npm)
    create(:sbom_occurrence, component: eslint, component_version: affected_version, pipeline: affected_pipeline)
    create(:sbom_occurrence, component: eslint, component_version: affected_version, pipeline: affected_twice_pipeline)
    create(:sbom_occurrence, component: eslint, component_version: affected_version, pipeline: affected_twice_pipeline)
    create(:sbom_occurrence, component: eslint, component_version: affected_version,
      pipeline: invalid_affected_pipeline)
    create(:sbom_occurrence, component: eslint, component_version: unaffected_version, pipeline: unaffected_pipeline)
  end

  describe '#execute' do
    before do
      allow(Time).to receive(:current).and_return(Time.new(2023, 11, 14, 0, 0, 0, '+00:00'))
      allow(Gitlab::VulnerabilityScanning::TrackCvsService).to receive(:new).and_call_original
      allow(Gitlab::AppJsonLogger).to receive(:debug).and_call_original
      allow(Gitlab::AppJsonLogger).to receive(:error).and_call_original

      described_class.scan_projects_for(affected_package.advisory)
    end

    context 'when the advisory matches component versions' do
      it 'creates vulnerabilities in valid affected projects only' do
        advisory = affected_package.advisory

        expect(affected_project.vulnerabilities).to match_array([
          have_attributes(
            author_id: user.id,
            project_id: affected_pipeline.project.id,
            state: 'detected',
            confidence: 'unknown',
            report_type: 'dependency_scanning',
            present_on_default_branch: true,
            title: advisory.title,
            severity: advisory.cvss_v3.severity.downcase,
            finding_description: advisory.description,
            solution: affected_package.solution
          )
        ])

        expect(affected_twice_project.vulnerabilities).to match_array([
          have_attributes(
            author_id: user_2.id,
            project_id: affected_twice_pipeline.project.id,
            state: 'detected',
            confidence: 'unknown',
            report_type: 'dependency_scanning',
            present_on_default_branch: true,
            title: advisory.title,
            severity: advisory.cvss_v3.severity.downcase,
            finding_description: advisory.description,
            solution: affected_package.solution
          ),
          have_attributes(
            author_id: user_2.id,
            project_id: affected_twice_pipeline.project.id,
            state: 'detected',
            confidence: 'unknown',
            report_type: 'dependency_scanning',
            present_on_default_branch: true,
            title: advisory.title,
            severity: advisory.cvss_v3.severity.downcase,
            finding_description: advisory.description,
            solution: affected_package.solution
          )
        ])

        expect(unaffected_project.vulnerabilities).to be_empty
        expect(invalid_affected_project.vulnerabilities).to be_empty
      end

      it "logs a debug message for the scan" do
        expect(Gitlab::AppJsonLogger).to have_received(:debug).with(
          message: 'Successfully created vulnerabilities on advisory ingestion',
          project_ids_with_upsert: [affected_project.id, affected_twice_project.id],
          project_ids_with_error: [invalid_affected_project.id],
          source_xid: 'glad', advisory_xid: affected_package.advisory.advisory_xid)
      end

      it "tracks an event for the scan" do
        expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
          advisory: affected_package.advisory,
          start_time: Time.current.iso8601,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: 4,
            possibly_affected_sbom_occurrences: 5,
            known_affected_projects: 3,
            known_affected_sbom_occurrences: 4
          }
        )
      end
    end

    context 'when component matches but version is not in the affected range' do
      let(:affected_range) { '<0.1.0' }

      it 'does not attempt to create an empty list of vulnerabilities' do
        expect(affected_project.vulnerabilities).to be_empty
        expect(affected_twice_project.vulnerabilities).to be_empty
        expect(Gitlab::AppJsonLogger).not_to have_received(:error)
      end
    end
  end
end
