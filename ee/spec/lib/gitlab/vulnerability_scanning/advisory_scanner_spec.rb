# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Gitlab::VulnerabilityScanning::AdvisoryScanner, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }
  let_it_be(:user_2) { create(:user) }

  let_it_be_with_reload(:affected_project) { create(:project) }
  let_it_be(:affected_pipeline) { create(:ci_pipeline, user: user, project: affected_project) }
  let_it_be(:affected_version) { create(:sbom_component_version, version: '0.9.0') }

  let_it_be(:affected_project_2) { create(:project) }
  # A user is required to attribute vulnerability creation to a user, hence the omission of a user
  # for the pipeline here.
  let_it_be(:invalid_affected_pipeline) { create(:ci_pipeline, project: affected_project_2) }

  let_it_be_with_reload(:affected_project_3) { create(:project) }
  let_it_be(:affected_pipeline_3) { create(:ci_pipeline, user: user_2, project: affected_project_3) }

  let_it_be(:unaffected_project) { create(:project) }
  let_it_be(:unaffected_pipeline) { create(:ci_pipeline, user: user, project: unaffected_project) }
  let_it_be(:unaffected_version) { create(:sbom_component_version, version: '1.0.0') }

  let_it_be(:affected_package) do
    create(:pm_affected_package, package_name: 'eslint', purl_type: :npm, affected_range: '>=0.8.0 <1.0.0')
  end

  before_all do
    eslint = create(:sbom_component, name: 'eslint', purl_type: :npm)
    create(:sbom_occurrence, component: eslint, component_version: affected_version, pipeline: affected_pipeline)
    create(:sbom_occurrence, component: eslint, component_version: affected_version, pipeline: affected_pipeline_3)
    create(:sbom_occurrence, component: eslint, component_version: affected_version,
      pipeline: invalid_affected_pipeline)
    create(:sbom_occurrence, component: eslint, component_version: unaffected_version, pipeline: unaffected_pipeline)
  end

  describe '#execute' do
    let_it_be(:global) { false }
    let_it_be(:ga_flag_enabled) { true }

    before do
      allow(Time).to receive(:current).and_return(Time.new(2023, 11, 14, 0, 0, 0, '+00:00'))
      allow(Gitlab::VulnerabilityScanning::TrackCvsService).to receive(:new).and_call_original
      allow(Gitlab::AppJsonLogger).to receive(:debug).and_call_original
      allow(Gitlab::AppJsonLogger).to receive(:error).and_call_original

      stub_feature_flags(global_dependency_scanning_on_advisory_ingestion: ga_flag_enabled)

      described_class.scan_projects_for(affected_package.advisory, global: global)
    end

    context 'when the projects have cvs_enabled' do
      before_all do
        affected_project.security_setting.update!(continuous_vulnerability_scans_enabled: true)
        affected_project_2.security_setting.update!(continuous_vulnerability_scans_enabled: true)
      end

      it 'creates a vulnerability in the affected project' do
        advisory = affected_package.advisory
        vulnerabilities = affected_project.vulnerabilities

        expect(vulnerabilities).to match_array([
          have_attributes(
            author_id: user.id,
            project_id: affected_pipeline.project.id,
            state: 'detected',
            confidence: 'unknown',
            report_type: 'dependency_scanning',
            present_on_default_branch: true,
            title: advisory.title,
            severity: advisory.cvss_v3.severity.downcase,
            finding_description: advisory.description,
            solution: affected_package.solution
          )
        ])

        expect(Gitlab::AppJsonLogger).to have_received(:debug).with(
          message: 'Successfully created vulnerabilities on advisory ingestion',
          project_ids_with_upsert: [affected_project.id],
          project_ids_with_error: [affected_project_2.id],
          source_xid: 'glad',
          advisory_xid: advisory.advisory_xid)

        expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
          advisory: advisory,
          start_time: Time.current.iso8601,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: 2,
            possibly_affected_sbom_occurrences: 2,
            known_affected_projects: 2,
            known_affected_sbom_occurrences: 2
          },
          global: false
        )
      end

      it 'does not create a vulnerability in the unaffected project' do
        vulnerabilities = unaffected_project.vulnerabilities
        expect(vulnerabilities).to be_empty
        expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
          advisory: affected_package.advisory,
          start_time: Time.current.iso8601,
          end_time: Time.current.iso8601,
          counts: {
            possibly_affected_projects: 2,
            known_affected_projects: 2,
            possibly_affected_sbom_occurrences: 2,
            known_affected_sbom_occurrences: 2
          },
          global: false
        )
      end
    end

    context 'when the projects do not have cvs_enabled' do
      context 'and the scan is global' do
        let_it_be(:global) { true }

        context 'and global scans are enabled' do
          let_it_be(:ga_flag_enabled) { true }

          it 'creates a vulnerability in valid affected projects' do
            advisory = affected_package.advisory

            expect(affected_project.vulnerabilities).to match_array([
              have_attributes(
                author_id: user.id,
                project_id: affected_pipeline.project.id,
                state: 'detected',
                confidence: 'unknown',
                report_type: 'dependency_scanning',
                present_on_default_branch: true,
                title: advisory.title,
                severity: advisory.cvss_v3.severity.downcase,
                finding_description: advisory.description,
                solution: affected_package.solution
              )
            ])
            expect(affected_project_3.vulnerabilities).to match_array([
              have_attributes(
                author_id: user_2.id,
                project_id: affected_pipeline_3.project.id,
                state: 'detected',
                confidence: 'unknown',
                report_type: 'dependency_scanning',
                present_on_default_branch: true,
                title: advisory.title,
                severity: advisory.cvss_v3.severity.downcase,
                finding_description: advisory.description,
                solution: affected_package.solution
              )
            ])

            expect(Gitlab::AppJsonLogger).to have_received(:debug).with(
              message: 'Successfully created vulnerabilities on advisory ingestion',
              project_ids_with_upsert: [affected_project.id, affected_project_3.id],
              project_ids_with_error: [affected_project_2.id],
              source_xid: 'glad', advisory_xid: advisory.advisory_xid)

            expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
              advisory: advisory,
              start_time: Time.current.iso8601,
              end_time: Time.current.iso8601,
              counts: {
                possibly_affected_projects: 4,
                possibly_affected_sbom_occurrences: 4,
                known_affected_projects: 3,
                known_affected_sbom_occurrences: 3
              },
              global: true
            )
          end
        end

        context 'and global scans are disabled' do
          let_it_be(:ga_flag_enabled) { false }

          it 'does not create a vulnerability in the affected project' do
            expect(affected_project.vulnerabilities).to be_empty
            expect(Gitlab::VulnerabilityScanning::TrackCvsService).not_to have_received(:new)
          end
        end
      end

      context 'and the scan is not global' do
        let_it_be(:global) { false }

        it 'does not create a vulnerability in the affected project' do
          expect(affected_project.vulnerabilities).to be_empty
          expect(Gitlab::VulnerabilityScanning::TrackCvsService).to have_received(:new).with(
            advisory: affected_package.advisory,
            start_time: Time.current.iso8601,
            end_time: Time.current.iso8601,
            counts: {
              possibly_affected_projects: 0,
              possibly_affected_sbom_occurrences: 0,
              known_affected_projects: 0,
              known_affected_sbom_occurrences: 0
            },
            global: false
          )
        end
      end
    end
  end
end
