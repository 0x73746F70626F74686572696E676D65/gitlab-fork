# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityPolicy, feature_category: :vulnerability_management do
  describe '#rules' do
    let(:project) { create(:project) }
    let(:user) { create(:user) }
    let(:vulnerability) { create(:vulnerability, :with_finding, project: project) }

    subject { described_class.new(user, vulnerability) }

    context 'when the security_dashboard feature is enabled' do
      before do
        stub_licensed_features(security_dashboard: true)
      end

      context "when the current user is not a project member" do
        it { is_expected.to be_disallowed(:read_security_resource) }
        it { is_expected.to be_disallowed(:read_vulnerability) }
        it { is_expected.to be_disallowed(:create_note) }
        it { is_expected.to be_disallowed(:explain_vulnerability) }
        it { is_expected.to be_disallowed(:resolve_vulnerability) }
      end

      context "when the current user has developer access to the vulnerability's project" do
        before do
          project.add_developer(user)
        end

        it { is_expected.to be_allowed(:read_security_resource) }
        it { is_expected.to be_allowed(:read_vulnerability) }
        it { is_expected.to be_allowed(:create_note) }
      end

      context 'when the security_dashboard feature is disabled' do
        before do
          stub_licensed_features(security_dashboard: false)
          project.add_developer(user)
        end

        it { is_expected.to be_disallowed(:read_security_resource) }
        it { is_expected.to be_disallowed(:read_vulnerability) }
        it { is_expected.to be_disallowed(:create_note) }
      end

      context 'when the user is project member but does not have proper access' do
        before do
          project.add_guest(user)
        end

        it do
          is_expected.to be_disallowed(:create_note)
        end
      end
    end

    describe 'explain_vulnerability' do
      let(:authorizer) { instance_double(::Gitlab::Llm::FeatureAuthorizer) }

      before do
        stub_licensed_features(security_dashboard: true)
        project.add_developer(user)
        allow(::Gitlab::Llm::FeatureAuthorizer).to receive(:new).and_return(authorizer)
      end

      context 'when feature is authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(true)
        end

        context 'when explain_vulnerability is enabled' do
          it { is_expected.to be_allowed(:explain_vulnerability) }
        end

        context 'when explain_vulnerability is disabled' do
          before do
            stub_feature_flags(explain_vulnerability: false)
          end

          it { is_expected.to be_disallowed(:explain_vulnerability) }
        end

        context 'when user cannot read_security_resource' do
          before do
            project.add_guest(user)
          end

          it { is_expected.to be_disallowed(:explain_vulnerability) }
        end

        context 'without finding' do
          let(:vulnerability) { build(:vulnerability, project: project) }

          it { is_expected.to be_disallowed(:explain_vulnerability) }
        end
      end

      context 'when feature is not authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(false)
        end

        it { is_expected.to be_disallowed(:explain_vulnerability) }
      end
    end

    describe 'resolve_vulnerability' do
      let(:authorizer) { instance_double(::Gitlab::Llm::FeatureAuthorizer) }

      before do
        stub_licensed_features(security_dashboard: true)
        project.add_developer(user)
        allow(::Gitlab::Llm::FeatureAuthorizer).to receive(:new).and_return(authorizer)
      end

      context 'when feature is authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(true)
        end

        context 'when resolve_vulnerability_ai is enabled' do
          it { is_expected.to be_allowed(:resolve_vulnerability) }
        end

        context 'when resolve_vulnerability_ai is disabled' do
          before do
            stub_feature_flags(resolve_vulnerability_ai: false)
          end

          it { is_expected.to be_disallowed(:resolve_vulnerability) }
        end

        context 'when user cannot read_security_resource' do
          before do
            project.add_guest(user)
          end

          it { is_expected.to be_disallowed(:resolve_vulnerability) }
        end

        context 'without finding' do
          let(:vulnerability) { build(:vulnerability, project: project) }

          it { is_expected.to be_disallowed(:resolve_vulnerability) }
        end
      end

      context 'when feature is not authorized' do
        before do
          allow(authorizer).to receive(:allowed?).and_return(false)
        end

        it { is_expected.to be_disallowed(:resolve_vulnerability) }
      end
    end
  end
end
