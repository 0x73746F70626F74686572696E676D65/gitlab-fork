# frozen_string_literal: true

require 'spec_helper'

RSpec.describe VulnerabilityExports::ExportService, feature_category: :vulnerability_management do
  describe '::export' do
    let(:vulnerability_export) { create(:vulnerability_export) }
    let(:mock_service_object) { instance_double(described_class, export: true) }

    subject(:export) { described_class.export(vulnerability_export) }

    before do
      allow(described_class).to receive(:new).and_return(mock_service_object)
    end

    it 'instantiates a new instance of the service class and sends export message to it' do
      export

      expect(described_class).to have_received(:new).with(vulnerability_export)
      expect(mock_service_object).to have_received(:export)
    end
  end

  describe '#export' do
    let!(:vulnerability_export) { create(:vulnerability_export, :created) }
    let(:service_object) { described_class.new(vulnerability_export) }

    subject(:export) { service_object.export }

    context 'generating the export file' do
      let(:lease_name) { "vulnerability_exports_export:#{vulnerability_export.id}" }

      before do
        allow(service_object).to receive(:in_lock)
      end

      it 'runs synchronized with distributed semaphore' do
        export

        expect(service_object).to have_received(:in_lock).with(lease_name, ttl: 1.hour)
      end
    end

    context 'when the vulnerability_export is not in `created` state' do
      before do
        allow(vulnerability_export).to receive(:created?).and_return(false)
        allow(service_object).to receive(:generate_export)
      end

      it 'does not execute export file generation logic' do
        export

        expect(service_object).not_to have_received(:generate_export)
      end
    end

    context 'when the vulnerability_export is in `created` state' do
      before do
        allow(VulnerabilityExports::ExportDeletionWorker).to receive(:perform_in)
      end

      context 'when the export generation fails' do
        let(:error) { RuntimeError.new('foo') }

        before do
          allow(service_object).to receive(:generate_export_file).and_raise(error)
        end

        it 'sets the state of export back to `created`' do
          expect { export }.to raise_error(error)
          expect(vulnerability_export.reload.created?).to be_truthy
        end

        it 'schedules the export deletion background job' do
          expect { export }.to raise_error(error)
          expect(VulnerabilityExports::ExportDeletionWorker).to have_received(:perform_in).with(1.hour, vulnerability_export.id)
        end
      end

      context 'when the export generation succeeds' do
        before do
          allow(service_object).to receive(:generate_export_file)
          allow(vulnerability_export).to receive(:start!)
          allow(vulnerability_export).to receive(:finish!)
        end

        it 'marks the state of export object as `started` and then `finished`' do
          export

          expect(vulnerability_export).to have_received(:start!).ordered
          expect(vulnerability_export).to have_received(:finish!).ordered
        end

        it 'schedules the export deletion background job' do
          export

          expect(VulnerabilityExports::ExportDeletionWorker).to have_received(:perform_in).with(1.hour, vulnerability_export.id)
        end
      end

      context 'when the export format is csv' do
        let(:vulnerabilities) { Vulnerability.none }
        let(:mock_relation) { double(:relation, with_findings_scanner_identifiers_and_notes: vulnerabilities) }
        let(:mock_vulnerability_finder_service_object) { instance_double(Security::VulnerabilitiesFinder, execute: mock_relation) }
        let(:exportable_full_path) { 'foo' }
        let(:time_suffix) { Time.current.utc.strftime('%FT%H%M') }
        let(:expected_file_name) { "#{exportable_full_path}_vulnerabilities_#{time_suffix}.csv" }

        before do
          allow(Security::VulnerabilitiesFinder).to receive(:new).and_return(mock_vulnerability_finder_service_object)
          allow(vulnerability_export.exportable).to receive(:full_path).and_return(exportable_full_path)
        end

        around do |example|
          freeze_time { example.run }
        end

        it 'calls the VulnerabilityExports::Exporters::CsvService which sets the file and filename' do
          expect { export }.to change { vulnerability_export.file }
                           .and change { vulnerability_export.file&.filename }.from(nil).to(expected_file_name)
        end

        context 'when generating an export for a group' do
          let_it_be(:group) { create(:group) }
          let_it_be(:group_b) { create(:group, parent: group) }
          let_it_be(:project_a) { create(:project, group: group) }
          let_it_be(:project_b) { create(:project, group: group_b) }
          let_it_be(:project_c) { create(:project, :archived, group: group_b) }
          let_it_be(:vulnerabilities_a) { create_list(:vulnerability, 2, :detected, :with_read, project: project_a) }
          let_it_be(:vulnerabilities_b) { create_list(:vulnerability, 2, :detected, :with_read, project: project_b) }
          let_it_be(:vulnerabilities_c) { create_list(:vulnerability, 2, :detected, :with_read, project: project_c) }

          let(:vulnerability_export) { create(:vulnerability_export, :csv, group: group, project: nil) }

          it 'avoids N+1 queries' do
            export_2 = create(:vulnerability_export, :csv, group: group_b, project: nil)
            control = ActiveRecord::QueryRecorder.new(skip_cached: false) { described_class.new(export_2).export }

            expect { export }.not_to exceed_query_limit(control)
          end

          it 'updates the state of the export' do
            export

            expect(vulnerability_export.finished_at).to be_present
            expect(vulnerability_export).to be_finished
            expect(vulnerability_export).to be_completed
          end

          it 'appends each vulnerability to a CSV file' do
            export

            csv = CSV.read(vulnerability_export.file.path, headers: true)

            expect(csv.headers).to be_present
            expect(csv['Vulnerability']).to match_array(
              vulnerabilities_a.map(&:title) +
              vulnerabilities_b.map(&:title)
            )
          end

          context 'with `optimized_vulnerability_report_export` disabled' do
            before do
              stub_feature_flags(optimized_vulnerability_report_export: false)
            end

            it 'appends each vulnerability to a CSV file' do
              export

              csv = CSV.read(vulnerability_export.file.path, headers: true)

              expect(csv.headers).to be_present
              expect(csv['Vulnerability']).to match_array(
                vulnerabilities_a.map(&:title) +
                vulnerabilities_b.map(&:title)
              )
            end
          end
        end
      end
    end
  end
end
