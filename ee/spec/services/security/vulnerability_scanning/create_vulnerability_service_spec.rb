# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::CreateVulnerabilityService, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }
  let_it_be(:pipeline) { create(:ci_pipeline, user: user) }
  let(:sbom_source) { build(:ci_reports_sbom_source) }
  let(:affected_components) do
    [
      build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project,
        source: sbom_source)
    ]
  end

  let(:advisory) { build(:vs_advisory) }

  subject(:service_response) do
    described_class.execute(advisory: advisory, affected_components: affected_components)
  end

  before do
    allow(Gitlab::ErrorTracking).to receive(:track_exception).and_call_original
  end

  describe '#execute' do
    context 'when the component type is supported' do
      it 'creates new vulnerabilities' do
        expect(service_response.payload[:error]).to be_nil
        expect(service_response.success?).to be(true)

        vuln_ids = service_response.payload[:vulnerability_ids]
        expect(vuln_ids).not_to be_empty

        vulns_created = Vulnerability.find(vuln_ids)
        expect(vulns_created).to match_array([
          have_attributes(
            author_id: user.id,
            project_id: pipeline.project_id,
            state: 'detected',
            confidence: 'unknown',
            report_type: 'dependency_scanning',
            present_on_default_branch: true,
            title: advisory.title,
            severity: advisory.cvss_v3.severity.downcase,
            finding_description: advisory.description,
            solution: advisory.solution
          )
        ])
      end
    end

    context 'when the findings are not uniq by uuid' do
      let(:affected_components) do
        build_list(:vs_possibly_affected_component, 2, purl_type: 'npm', name: 'component-one', version: 'v0.0.1',
          pipeline: pipeline, source: sbom_source)
      end

      it 'does not return an error' do
        expect(service_response.payload[:error]).to be_nil
        expect(service_response.success?).to be(true)
      end
    end

    context 'when the component type is not supported' do
      let(:affected_components) do
        [
          build(:vs_possibly_affected_component, purl_type: 'foo', pipeline: pipeline, project: pipeline.project)
        ]
      end

      it 'fails to create a new vulnerability with error' do
        expect(service_response.success?).to be(false)
        expect(service_response.payload[:vulnerability_ids]).to be_nil
        expect(service_response.payload[:error]).not_to be_nil
        expect(service_response.payload[:error]).to be_a_kind_of(
          StandardError
        )
        expect(service_response.payload[:error].message).to eq(
          "No finding builder found for component"
        )
      end
    end

    context 'when an error is thrown' do
      context 'and it is not recoverable' do
        it 'captures the error and halts execution' do
          allow_next_instance_of(::Gitlab::VulnerabilityScanning::FindingBuilder) do |instance|
            allow(instance).to receive(:finding).and_raise(StandardError)
          end

          expect(Gitlab::ErrorTracking).to receive(:track_exception)
            .with(an_instance_of(StandardError),
              message: "Continuous vulnerability scanning failed to create vulnerabilities",
              project_ids_with_upsert: [],
              project_ids_with_error: [],
              advisory_xid: advisory.xid)

          expect(service_response.success?).to be(false)
          expect(service_response.message).to eq('Vulnerabilities were not created')
          expect(service_response.payload[:vulnerability_ids]).to be_nil
          expect(service_response.payload[:error]).not_to be_nil
          expect(service_response.payload[:error]).to be_a_kind_of(StandardError)
          expect(service_response.payload[:error]).to be_kind_of(StandardError)
        end
      end

      context 'and it is a recoverable finding builder error' do
        let(:valid_component) do
          build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project,
            source: sbom_source)
        end

        let(:invalid_source_component) do
          build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project,
            source: nil)
        end

        let(:affected_components) { [valid_component, invalid_source_component] }

        it 'captures and tracks the error' do
          expect(Gitlab::ErrorTracking).to receive(:track_exception)
                  .with(an_instance_of(::Gitlab::VulnerabilityScanning::FindingBuilder::ArgumentError),
                    message: 'Skipping vulnerability creation for an affected component',
                    project_id: pipeline.project.id,
                    advisory_xid: advisory.xid)

          expect(service_response.success?).to be(true)
          expect(service_response.payload[:vulnerability_ids].size).to eq(1)
          expect(service_response.payload[:project_ids_with_upsert]).to eq([pipeline.project.id])
          expect(service_response.payload[:project_ids_with_error]).to eq([pipeline.project.id])
          expect(service_response.payload[:error]).to be_nil
        end
      end
    end
  end
end
