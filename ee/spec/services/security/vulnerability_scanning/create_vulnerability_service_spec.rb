# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::CreateVulnerabilityService, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }
  let_it_be(:pipeline) { create(:ci_pipeline, user: user) }
  let(:sbom_source) { build(:ci_reports_sbom_source) }
  let(:affected_components) do
    [
      build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project)
    ]
  end

  let(:advisory) { build(:vs_advisory) }

  subject(:service_response) do
    described_class.execute(advisory: advisory, affected_components: affected_components)
  end

  before do
    allow(Gitlab::ErrorTracking).to receive(:track_exception).and_call_original
  end

  describe '#execute' do
    context 'when the component type is supported' do
      it 'creates new vulnerabilities' do
        expect(service_response.payload[:error]).to be_nil
        expect(service_response.success?).to be(true)

        vuln_ids = service_response.payload[:vulnerability_ids]
        expect(vuln_ids).not_to be_empty

        vulns_created = Vulnerability.find(vuln_ids)
        expect(vulns_created).to match_array([
          have_attributes(
            author_id: user.id,
            project_id: pipeline.project_id,
            state: 'detected',
            confidence: 'unknown',
            report_type: 'dependency_scanning',
            present_on_default_branch: true,
            title: advisory.title,
            severity: advisory.cvss_v3.severity.downcase,
            finding_description: advisory.description,
            solution: advisory.solution
          )
        ])
      end
    end

    context 'when the component type is not supported' do
      let(:affected_components) do
        [
          build(:vs_possibly_affected_component, purl_type: 'foo', pipeline: pipeline, project: pipeline.project)
        ]
      end

      it 'fails to create a new vulnerability with error' do
        expect(service_response.success?).to be(false)
        expect(service_response.payload[:vulnerability_ids]).to be_nil
        expect(service_response.payload[:error]).not_to be_nil
        expect(service_response.payload[:error]).to be_a_kind_of(
          StandardError
        )
        expect(service_response.payload[:error].message).to eq(
          "No finding builder found for component"
        )
      end
    end

    context 'when the pipeline has no associated user' do
      let_it_be(:pipeline) { create(:ci_pipeline) }

      it 'fails to create a new vulnerability' do
        expect(Gitlab::ErrorTracking)
          .to receive(:track_exception)
          .with(ArgumentError.new('Pipeline must have a corresponding user to use as vulnerability author'),
            message: 'Skipping vulnerability creation for project',
            project_id: pipeline.project.id,
            advisory_xid: advisory.xid)

        expect(Gitlab::ErrorTracking)
          .to receive(:track_exception)
          .with(anything,
            message: 'Continuous vulnerability scanning failed to create vulnerabilities',
            project_ids_with_upsert: [],
            project_ids_with_error: [pipeline.project.id],
            advisory_xid: advisory.xid).once

        expect(service_response.success?).to be(false)
        expect(service_response.payload[:vulnerability_ids]).to be_nil
        expect(service_response.payload[:error]).not_to be_nil
        expect(service_response.payload[:error]).to be_a_kind_of(StandardError)
        expect(service_response.payload[:error].message).to eq(
          'No vulnerability scanning finding maps could be created'
        )
      end
    end
  end
end
