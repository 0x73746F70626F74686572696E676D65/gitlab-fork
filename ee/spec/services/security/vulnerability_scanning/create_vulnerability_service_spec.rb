# frozen_string_literal: true

require 'spec_helper'

RSpec.describe Security::VulnerabilityScanning::CreateVulnerabilityService, feature_category: :software_composition_analysis do
  let_it_be(:user) { create(:user) }
  let_it_be_with_refind(:project) { create(:project) }
  let_it_be_with_refind(:pipeline) { create(:ci_pipeline, user: user, project: project) }

  let(:sbom_source) { build(:ci_reports_sbom_source) }
  let(:affected_components) do
    [
      build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project,
        source: sbom_source)
    ]
  end

  let(:advisory) { build(:vs_advisory) }

  subject(:service_response) do
    described_class.execute(advisory: advisory, affected_components: affected_components)
  end

  before do
    allow(Gitlab::ErrorTracking).to receive(:track_exception).and_call_original
  end

  describe '#execute' do
    context 'when the component type is supported' do
      shared_examples 'vulnerability creation' do
        let(:created_vulnerability) { Vulnerability.find(service_response.payload[:vulnerability_ids].first) }

        it 'creates a new vulnerabilities' do
          expect(service_response.payload[:error]).to be_nil
          expect(service_response.success?).to be(true)
          expect(service_response.payload[:vulnerability_ids].length).to be(1)

          expect(created_vulnerability).to have_attributes(
            author_id: user.id,
            project_id: pipeline.project_id,
            state: 'detected',
            confidence: 'unknown',
            report_type: report_type,
            present_on_default_branch: true,
            title: advisory.title,
            severity: advisory.cvss_v3.severity.downcase,
            finding_description: advisory.description,
            solution: advisory.solution
          )
        end

        describe 'updating the `vulnerability_reads`' do
          let(:vulnerability_read) { created_vulnerability.vulnerability_read }

          it 'sets the `traversal_ids` for the `vulnerability_reads` records' do
            expect(vulnerability_read.traversal_ids).to eq(project.namespace.traversal_ids)
          end

          context 'when the project is unarchived' do
            it 'marks the associated `vulnerability_reads` record as unarchived' do
              expect(vulnerability_read.archived).to be_falsey
            end
          end

          context 'when the project is archived' do
            before do
              project.update!(archived: true)
            end

            it 'marks the associated `vulnerability_reads` record as archived' do
              expect(vulnerability_read.archived).to be_truthy
            end
          end
        end
      end

      context 'when report type and source is dependency scanning' do
        let(:report_type) { 'dependency_scanning' }

        it_behaves_like 'vulnerability creation'
      end

      context 'when report type and source is container scanning' do
        let(:affected_components) do
          [
            build(:vs_possibly_affected_component, :container_scanning, pipeline: pipeline, project: pipeline.project)
          ]
        end

        let(:report_type) { 'container_scanning' }

        it_behaves_like 'vulnerability creation'
      end

      context 'when report type and source is container scanning for registry' do
        let(:affected_components) do
          [
            build(:vs_possibly_affected_component,
              :container_scanning_for_registry, pipeline: pipeline, project: pipeline.project)
          ]
        end

        let(:report_type) { 'container_scanning_for_registry' }

        it_behaves_like 'vulnerability creation'
      end

      it_behaves_like 'rescheduling archival status and traversal_ids update jobs' do
        let(:scheduling_method) { :bulk_perform_async_with_contexts }
        let(:job_args) do
          [
            [pipeline.project],
            {
              arguments_proc: an_instance_of(Proc),
              context_proc: an_instance_of(Proc)
            }
          ]
        end

        let(:ingest_vulnerabilities) { service_response }
        let(:update_archived_after_start) do
          allow(Security::Ingestion::IngestCvsSliceService).to receive(:execute).and_wrap_original do |method, *args|
            pipeline.project.clone.reload.update_column(:archived, true)

            method.call(*args)
          end
        end

        let(:update_traversal_ids_after_start) do
          allow(Security::Ingestion::IngestCvsSliceService).to receive(:execute).and_wrap_original do |method, *args|
            pipeline.project.namespace.clone.reload.update_column(:traversal_ids, [-1])

            method.call(*args)
          end
        end

        let(:update_namespace_after_start) do
          allow(Security::Ingestion::IngestCvsSliceService).to receive(:execute).and_wrap_original do |method, *args|
            pipeline.project.clone.reload.update_column(:namespace_id, new_namespace.id)

            method.call(*args)
          end
        end
      end
    end

    context 'when the findings are not uniq by uuid' do
      let(:affected_components) do
        build_list(:vs_possibly_affected_component, 2, purl_type: 'npm', name: 'component-one', version: 'v0.0.1',
          pipeline: pipeline, source: sbom_source)
      end

      it 'does not return an error' do
        expect(service_response.payload[:error]).to be_nil
        expect(service_response.success?).to be(true)
      end
    end

    context 'when no finding maps could be created' do
      let(:invalid_source_component) do
        build(:vs_possibly_affected_component, purl_type: 'npm',
          pipeline: pipeline, project: pipeline.project,
          source: nil)
      end

      # This simulates the edge case because no finding maps
      # will be created if the component does not have a source.
      let(:affected_components) { [invalid_source_component] }

      it 'returns a success status with warning' do
        expect(service_response.payload[:error]).to be_nil
        expect(service_response.success?).to be(true)
        expect(service_response.message).to be('All finding maps filtered out and no vulnerabilities created')
        expect(service_response.payload[:vulnerability_ids]).to eq([])
        expect(service_response.payload[:project_ids_with_upsert]).to eq([])
        expect(service_response.payload[:project_ids_with_error]).to eq([pipeline.project.id])
      end
    end

    context 'when the component type is not supported' do
      let(:affected_components) do
        [
          build(:vs_possibly_affected_component, purl_type: 'foo', pipeline: pipeline, project: pipeline.project)
        ]
      end

      it 'fails to create a new vulnerability with error' do
        expect(service_response.success?).to be(false)
        expect(service_response.payload[:vulnerability_ids]).to be_nil
        expect(service_response.payload[:error]).not_to be_nil
        expect(service_response.payload[:error]).to be_a_kind_of(
          StandardError
        )
        expect(service_response.payload[:error].message).to eq(
          "No finding builder found for component"
        )
      end
    end

    context 'when an error is thrown' do
      context 'and it is not recoverable' do
        it 'captures the error and halts execution' do
          allow_next_instance_of(::Gitlab::VulnerabilityScanning::FindingBuilder) do |instance|
            allow(instance).to receive(:finding).and_raise(StandardError)
          end

          expect(Gitlab::ErrorTracking).to receive(:track_exception)
            .with(an_instance_of(StandardError),
              message: "Continuous vulnerability scanning failed to create vulnerabilities",
              project_ids_with_upsert: [],
              project_ids_with_error: [],
              advisory_xid: advisory.xid,
              source_xid: advisory.source_xid)

          expect(service_response.success?).to be(false)
          expect(service_response.message).to eq('Vulnerabilities were not created')
          expect(service_response.payload[:vulnerability_ids]).to be_nil
          expect(service_response.payload[:error]).not_to be_nil
          expect(service_response.payload[:error]).to be_a_kind_of(StandardError)
          expect(service_response.payload[:error]).to be_kind_of(StandardError)
        end
      end

      context 'and it is a recoverable finding builder error' do
        let(:valid_component) do
          build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project,
            source: sbom_source)
        end

        let(:invalid_source_component) do
          build(:vs_possibly_affected_component, purl_type: 'npm', pipeline: pipeline, project: pipeline.project,
            source: nil)
        end

        let(:affected_components) { [valid_component, invalid_source_component] }

        it 'captures and tracks the error' do
          expect(Gitlab::ErrorTracking).to receive(:track_exception)
                  .with(an_instance_of(::Gitlab::VulnerabilityScanning::FindingBuilder::ArgumentError),
                    message: 'Skipping vulnerability creation for an affected component',
                    project_id: pipeline.project.id,
                    advisory_xid: advisory.xid,
                    source_xid: advisory.source_xid)

          expect(service_response.success?).to be(true)
          expect(service_response.payload[:vulnerability_ids].size).to eq(1)
          expect(service_response.payload[:project_ids_with_upsert]).to eq([pipeline.project.id])
          expect(service_response.payload[:project_ids_with_error]).to eq([pipeline.project.id])
          expect(service_response.payload[:error]).to be_nil
        end
      end
    end
  end
end
